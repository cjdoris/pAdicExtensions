function error_func(msg)
  error msg;
end function;

declare type PadRamifPgon;
declare attributes PadRamifPgon: F, vs, tvs, wvs, n, u, Js, bs, as, ss, pgon, valid_ore, valid_tame, valid_cong, valid_bound, valid_missing, is_valid, is_semivalid, residues, ccrespol, ccres;

declare type Tmpl_RngUPolElt_FldPadTmpl;
declare attributes Tmpl_RngUPolElt_FldPadTmpl: R, coeffs, index_set;

declare type Tmpl_FldPadTmplElt;
declare attributes Tmpl_FldPadTmplElt: F, min_val, min_val_sharp, max_val, residues, index_set;

Z := Integers();
Q := Rationals();

///# Miscellaneous

intrinsic FloorLog(b :: RngIntElt, x :: RngIntElt) -> RngIntElt
  {Equivalent to `Floor(Log(b,x))` but avoids any floating point arithmetic.}
  require b gt 0: "b must be positive";
  require x gt 0: "x must be positive";
  n := 0;
  while x ge b do
    n +:= 1;
    x div:= b;
  end while;
  return n;
end intrinsic;

// evaluates a piecewise-linear function vs at x
// vs: the function as a sequence of <x,y> pairs sorted by x
function plf_evaluate(vs, x)
  error if x lt vs[1][1] or x gt vs[#vs][1], "out of bounds";
  if #vs eq 1 then
    assert x eq vs[1][1];
    return vs[1][2];
  end if;
  assert exists(i){i : i in [2..#vs] | vs[i-1][1] le x and x le vs[i][1]};
  x0, y0 := Explode(vs[i-1]);
  x1, y1 := Explode(vs[i]);
  return y0 + (y1-y0)*(x-x0)/(x1-x0);  
end function;

intrinsic Evaluate(P :: NwtnPgon, x :: FldRatElt) -> FldRatElt
  {Treating P as a piecewise-linear function, evaluates it at x.}
  return plf_evaluate(Vertices(P), x);
end intrinsic;

intrinsic Evaluate(P :: NwtnPgon, x :: RngIntElt) -> FldRatElt
  {"}
  return Evaluate(P, Q!x);
end intrinsic;

intrinsic FactorialValuation(n :: RngIntElt, p :: RngIntElt) -> RngIntElt
  {The p-adic valuation of `n!` (equivalent to `Valuation(Factorial(n),p)` but more efficient).}
  require n ge 0: "n must be positive";
  v := 0;
  m := n;
  while m gt 0 do
    m div:= p;
    v +:= m;
  end while;
  return v;
end intrinsic;

intrinsic BinomialValuation(n :: RngIntElt, k :: RngIntElt, p :: RngIntElt) -> RngIntElt
  {The p-adic valuation of n choose k.}
  if k gt n or k lt 0 then
    return Infinity();
  else
    return FactorialValuation(n, p) - FactorialValuation(k, p) - FactorialValuation(n-k, p);
  end if;
end intrinsic;

intrinsic UnitFactorial(F :: FldFin, n :: RngIntElt) -> FldFinElt
  {The product of the integers up to n which are units in F. By Wilson's formula, if `n=kn+r` this is `(-1)^k * r!`.}
  require n ge 0: "n must be at least 0";
  p := Characteristic(F);
  if p eq 2 then
    return F ! 1;
  end if;
  k := n div p;
  r := n mod p;
  return (F!-1)^k * &*[F| i : i in [1..r]];
end intrinsic;

intrinsic ShiftedFactorial(F :: FldFin, n :: RngIntElt) -> FldFinElt
  {The product of the integers up to n shifted down to be units of F. This is the product of `UnitFactorial(n div p^i)` for all `i`.}
  require n ge 0: "n must be at least 0";
  p := Characteristic(F);
  if p eq 2 then
    return F ! 1;
  end if;
  ans := F!1;
  m := n;
  while m ne 0 do
    ans *:= UnitFactorial(F, m);
    m div:= p;
  end while;
  return ans;
end intrinsic;

intrinsic ShiftedBinomial(F :: FldFin, n :: RngIntElt, k :: RngIntElt) -> FldFinElt
  {The binomial coefficient n choose k shifted down to be a unit of F.}
  require 0 le n: "n must be at least 0";
  require 0 le k and k le n: "k must be between 0 and n";
  return ShiftedFactorial(F, n) / (ShiftedFactorial(F, k) * ShiftedFactorial(F, n-k));
end intrinsic;

///# Template p-adic fields
///
/// A "template" p-adic field represents a p-adic field K with only partial information known, such as its prime and absolute degree. For example, the number of extensions of K of a given degree d only depends on d, p, and the absolute inertia and ramification degrees, and so it is useful to have a representation of a field with such limited information.
/// 
/// Currently, the partial information we support is:
/// - The prime, `p`
/// - The absolute degree, `(K:Q_p)`
/// - The absolute inertia degree, `f(K:Q_p)`
/// - The absolute ramification degree, `e(K:Q_p)`
/// - The "uniformizer residue class", which is `pi^e/p` where `pi` is a uniformizer; this is well-defined up to a multiple by a `e`th power
/// - The actual field `K`, as a standard `FldPad` such as is returned by `pAdicField`.
/// 
///toc

declare type FldPadTmpl[FldPadTmplElt];
declare attributes FldPadTmpl
  // definition (all optional)
  : prime
  , degree
  , resdeg
  , ramdeg
  , unifres
  , actual
  // cache
  , resfld
  , resmap
  , polynomial_ring
  , actual_map;
declare attributes FldPadTmplElt: parent, coeffs, valuation;

declare type RngUPol_FldPadTmpl[RngUPolElt_FldPadTmpl];
declare attributes RngUPol_FldPadTmpl: base_ring, actual, actual_map;
declare attributes RngUPolElt_FldPadTmpl: parent, coeffs;

///## Creation

intrinsic TemplatepAdicField(:Prime:=false, Degree:=false, InertiaDegree:=false, RamificationDegree:=false, UniformizerResidue:=false, Actual:=false) -> FldPadTmpl
  {A "template" p-adic field with data given by the parameters.}
  require Prime cmpeq false or (Type(Prime) eq RngIntElt and Prime gt 0 and IsPrime(Prime)): "Prime must be a prime integer";
  require Degree cmpeq false or (Type(Degree) eq RngIntElt and Degree gt 0): "Degree must be a positive integer";
  require InertiaDegree cmpeq false or (Type(InertiaDegree) eq RngIntElt and InertiaDegree gt 0): "InertiaDegree must be a positive integer";
  require RamificationDegree cmpeq false or (Type(RamificationDegree) eq RngIntElt and InertiaDegree gt 0): "RamificationDegree must be a positive integer";
  require UniformizerResidue cmpeq false or (Type(UniformizerResidue) cmpeq FldFinElt and UniformizerResidue ne 0): "UniformizerResidue ";
  if Actual then
    F := TemplatepAdicField(Actual);
    error if Prime cmpne false and Prime cmpne F`prime, "Prime inconsistent with Actual";
    error if Degree cmpne false and Degree cmpne F`degree, "Degree inconsistent with Actual";
    error if InertiaDegree cmpne false and InertiaDegree cmpne F`resdeg, "InertiaDegree inconsistent with Actual";
    error if RamificationDegree cmpne false and RamificationDegree cmpne F`ramdeg, "RamificationDegree inconsistent with Actual";
    error if UniformizerResidue cmpne false and UniformizerResidue cmpne F`unifres, "UniformizerResidue inconsistent with Actual";
    return F;
  end if;
  if UniformizerResidue cmpne false then
    if Prime cmpne false then
      error if Prime ne Characteristic(Parent(UniformizerResidue)), "Prime inconsistent with UnformizerResidue";
    else
      Prime := Characteristic(Parent(UniformizerResidue));
    end if;
    if InertiaDegree cmpne false then
      error if InertiaDegree ne AbsoluteDegree(Parent(UniformizingElement)), "InertiaDegree inconsistent with UniformizerResiude";
    else
      InertiaDegree := AbsoluteDegree(Parent(UniformizingElement));
    end if;
  end if;
  if Degree cmpne false and InertiaDegree cmpne false and RamificationDegree cmpne false then
    error if Degree ne InertiaDegree * RamificationDegree, "Degree, InertiaDegree and RamificationDegree inconsistent";
  elif Degree cmpne false and InertiaDegree cmpne false then
    ok, RamificationDegree := IsDivisibleBy(Degree, InertiaDegree);
    error if not ok, "Degree not divisible by InertiaDegree";
  elif Degree cmpne false and RamificationDegree cmpne false then
    ok, InertiaDegree := IsDivisibleBy(Degree, RamificationDegree);
    error if not ok, "Degree not divisible by RamificationDegree";
  elif InertiaDegree cmpne false and RamificationDegree cmpne false then
    Degree := InertiaDegree * RamificationDegree;
  elif Degree cmpne false and Degree eq 1 then
    RamificationDegree := 1;
    InertiaDegree := 1;
  end if;
  if Prime cmpne false and RamificationDegree cmpne false and RamificationDegree eq 1 and InertiaDegree cmpne false then
    return TemplatepAdicField(Degree eq 1 select pAdicField(Prime) else ext<pAdicField(Prime) | Degree>);
  end if;
  F := New(FldPadTmpl);
  if Prime cmpne false then
    F`prime := Prime;
  end if;
  if Degree cmpne false then
    F`degree := Degree;
  end if;
  if InertiaDegree cmpne false then
    F`resdeg := InertiaDegree;
  end if;
  if RamificationDegree cmpne false then
    F`ramdeg := RamificationDegree;
  end if;
  if UniformizerResidue cmpne false then
    F`unifres := UniformizerResidue;
  end if;
  return F;
end intrinsic;

intrinsic TemplatepAdicField(p :: RngIntElt) -> FldPadTmpl
  {The "template" prime p-adic field `Q_p`. Equivalent to `TemplatepAdicField(pAdicField(p))`.}
  require p gt 0 and IsPrime(p): "p must be prime";
  return TemplatepAdicField(pAdicField(p));
end intrinsic;

intrinsic TemplatepAdicField(K :: FldPad) -> FldPadTmpl
  {A "template" version of K.}
  F := New(FldPadTmpl);
  F`prime := Prime(K);
  F`degree := AbsoluteDegree(K);
  F`resdeg := AbsoluteInertiaDegree(K);
  F`ramdeg := AbsoluteRamificationDegree(K);
  F`unifres := m(UniformizingElement(K)^F`ramdeg / F`prime) where _,m := ResidueClassField(Integers(K));
  F`actual := K;
  return F;
end intrinsic;

///hide
intrinsic Print(F :: FldPadTmpl)
  {Print.}
  printf "Template %o-adic field (d=%o, f=%o, e=%o)",
    ok select p else "?" where ok,p:=HasPrime(F),
    ok select d else "?" where ok,d:=HasAbsoluteDegree(F),
    ok select f else "?" where ok,f:=HasAbsoluteInertiaDegree(F),
    ok select e else "?" where ok,e:=HasAbsoluteRamificationDegree(F);
  ok, A := HasActual(F);
  if ok then
    printf " actually %o", A;
  end if;
end intrinsic;

///hide
intrinsic 'eq'(F :: FldPadTmpl, E :: FldPadTmpl) -> BoolElt
  {Equality.}
  return IsIdentical(F, E);
end intrinsic;

///## Invariants

intrinsic HasPrime(F :: FldPadTmpl) -> BoolElt, RngIntElt
  {True if the prime of F is known.}
  if assigned F`prime then
    return true, F`prime;
  else
    return false, _;
  end if;
end intrinsic;

intrinsic Prime(F :: FldPadTmpl) -> RngIntElt
  {The prime `p`.}
  if assigned F`prime then
    return F`prime;
  else
    error "Prime unknown";
  end if;
end intrinsic;

/// True if the absolute degree/inertia degree/ramification degree is known.
intrinsic HasAbsoluteDegree(F :: FldPadTmpl) -> BoolElt, RngIntElt
  {True if the absolute degree of F is known.}
  if assigned F`degree then
    return true, F`degree;
  else
    return false, _;
  end if;
end intrinsic;

///ditto
intrinsic HasAbsoluteInertiaDegree(F :: FldPadTmpl) -> BoolElt, RngIntElt
  {True if the absolute inertia degree of F is known.}
  if assigned F`resdeg then
    return true, F`resdeg;
  else
    return false, _;
  end if;
end intrinsic;

///ditto
intrinsic HasAbsoluteRamificationDegree(F :: FldPadTmpl) -> BoolElt, RngIntElt
  {True if the absolute ramification degree of F is known.}
  if assigned F`ramdeg then
    return true, F`ramdeg;
  else
    return false, _;
  end if;
end intrinsic;

/// Absolute degree, inertia degree and ramification degree.
intrinsic AbsoluteDegree(F :: FldPadTmpl) -> RngIntElt
  {Absolute degree.}
  if assigned F`degree then
    return F`degree;
  else
    error "Absolute degree unknown";
  end if;
end intrinsic;

///ditto
intrinsic AbsoluteInertiaDegree(F :: FldPadTmpl) -> RngIntElt
  {Absolute inertia degree.}
  if assigned F`resdeg then
    return F`resdeg;
  else
    error "Absolute inertia degree unknown";
  end if;
end intrinsic;

///ditto
intrinsic AbsoluteRamificationDegree(F :: FldPadTmpl) -> RngIntElt
  {Absolute ramification degree.}
  if assigned F`ramdeg then
    return F`ramdeg;
  else
    error "Absolute ramification degree unknown";
  end if;
end intrinsic;

intrinsic HasUniformizerResidue(F :: FldPadTmpl) -> BoolElt, FldFinElt
  {True if the uniformizer residue of F is known.}
  if assigned F`unifres then
    return true, F`unifres;
  else
    return false, _;
  end if;
end intrinsic;

intrinsic UniformizerResidue(F :: FldPadTmpl) -> FldFinElt
  {Uniformizer residue, the residue class of pi^e/p where pi is a uniformizer.}
  if assigned F`unifres then
    return F`unifres;
  else
    error "Uniformizer residue unknown";
  end if;
end intrinsic;

intrinsic HasResidueClassField(F :: FldPadTmpl) -> BoolElt, FldFin, Map
  {True if the residue class field of F is known. If so, returns it and the quotient map.}
  if not assigned F`resfld then
    if assigned F`actual then
      F`resfld := ResidueClassField(Integers(F`actual));
    else
      ok, p := HasPrime(F);
      if not ok then
        return false, p, _;
      end if;
      ok, f := HasAbsoluteInertiaDegree(F);
      if not ok then
        return false, f, _;
      end if;
      F`resfld := FiniteField(p, f);
    end if;
    F`resmap := map<F -> F`resfld | x :-> Valuation(x) eq 0 select x`coeffs[1] else Valuation(x) gt 0 select 0 else error_func("not an integer"), y :-> <0, [y]>>;
  end if;
  return true, F`resfld, F`resmap;
end intrinsic;

intrinsic ResidueClassField(F :: FldPadTmpl) -> FldFin, Map
  {Residue class field and the quotient map.}
  ok, FF, q := HasResidueClassField(F);
  require ok: FF;
  return FF, q;
end intrinsic;

intrinsic HasActual(F :: FldPadTmpl) -> BoolElt, FldPad, Map
  {True if F is associated to an actual field. If so, also returns the it and the embedding into it.}
  if assigned F`actual then
    if not assigned F`actual_map then
      F`actual_map := Embedding(F, F`actual);
    end if;
    return true, F`actual, F`actual_map;
  else
    return false, "Actual field unknown", _;
  end if;
end intrinsic;

intrinsic Actual(F :: FldPadTmpl) -> FldPad, Map
  {The actual field associated to F, if there is one.}
  ok, K, m := HasActual(F);
  require ok: K;
  return K, m;
end intrinsic;

intrinsic Embedding(F :: FldPadTmpl, A :: FldPad) -> Map
  {The embedding of F into A, which must share the same residue class field.}
  FF, q := ResidueClassField(Integers(A));
  pr := Precision(A);
  if pr eq Infinity() then
    function FtoA(x)
      if #x`coeffs eq 0 then
        return 0;
      else
        A2 := A;
        A2`DefaultPrecision := Max(A2`DefaultPrecision, #x`coeffs);
        pr2 := A2`DefaultPrecision;
        pi := UniformizingElement(A2);
        assert AbsolutePrecision(pi) ge 1+pr2;
        return ShiftValuation(&+[A| ShiftValuation(ChangePrecision(x`coeffs[i] @@ q, pr2), i-1) : i in [1..#x`coeffs]], x`valuation);
      end if;
    end function;
  else
    function FtoA(x)
      if #x`coeffs eq 0 then
        return 0;
      else
        return ShiftValuation(&+[A| ShiftValuation(ChangePrecision(x`coeffs[i] @@ q, pr), i-1) : i in [1..#x`coeffs]], x`valuation);
      end if;
    end function;
  end if;
  function AtoF(y)
    v := Valuation(y);
    if v eq Infinity() then
      return 0;
    else
      cs := [];
      y := ShiftValuation(y, -v);
      for i in [1..AbsolutePrecision(y)] do
        c := y @ q;
        Append(~cs, c);
        y := ShiftValuation(y - c @@ q, -1);
      end for;
      return <v, cs>;
    end if;
  end function;
  return map<F -> A | x :-> FtoA(x), y :-> AtoF(y)>;
end intrinsic;

///
/// **Note:** The embedding has an inverse defined, but it will enter an infinite loop unless the input can be represented as a finite polynomial in the uniformizer with coefficients representatives of the residue class field (i.e. the preimages of the residue map).
/// 
///param Place When given, this must be the prime ideal of A corresponding to the completion. By default it is computed from e, but the embedding depends on its generators, so you may get a nicer embedding using the original prime.
///param ResidueMap When given, this must be the residue map from the integers of A to the residue class field of F. By default it is computed from Place.
///param Uniformizer When given, this must be a uniformizing element for the prime. By default it is computed from Place.
intrinsic Embedding(F :: FldPadTmpl, A :: FldNum, e :: Map : Place:=false, ResidueMap:=false, Uniformizer:=false) -> Map
  {The embedding of F into A, where e is a completion map of A into a p-adic field.}
  K := Codomain(e);
  require Domain(e) cmpeq A and Type(K) eq FldPad: "e must be an completion of A into a p-adic field";
  OA := Integers(A);
  pidl := ideal<OA | Prime(K), UniformizingElement(K)@@e>;
  require IsPrime(pidl): "e must be a completion of A into a p-adic field";
  if Place cmpne false then
    require Place eq pidl: "Place does not match the embedding";
    pidl := Place;
  end if;
  if ResidueMap cmpeq false then
    _, q := ResidueClassField(pidl);
  else
    q := ResidueMap;
    require Type(q) eq Map and Domain(q) cmpeq Integers(A) and Codomain(q) cmpeq ResidueClassField(F) and forall{x : x in Generators(pidl) | x@q eq 0}: "ResidueMap is not a valid residue map";
  end if;
  if Uniformizer cmpeq false then
    pi := UniformizingElement(pidl);
  else
    pi := Uniformizer;
    require pi in A and Valuation(pi@e) eq 1: "Uniformizer must be a uniformizer in A";
  end if;
  function FtoA(x)
    v := Valuation(x);
    if v eq Infinity() then
      return 0;
    else
      return pi^v * &+[pi^(i-1) * (x`coeffs[i] @@ q) : i in [1..#x`coeffs]];
    end if;
  end function;
  function AtoF(y)
    if y eq 0 then
      return <0,[]>;
    else
      v := Valuation(y*OA, pidl);
      z := y * pi^(-v);
      assert Valuation(z*OA, pidl) eq 0;
      cs := [];
      while z ne 0 do
        c := z @ q;
        Append(~cs, c);
        z := (z - (c @@ q)) / pi;
      end while;
      return <v,cs>;
    end if;
  end function;
  return map<F -> A | x :-> FtoA(x), y :-> AtoF(y)>;
end intrinsic;

///## Ore's conditions

intrinsic OreConditions(F :: FldPadTmpl, n :: RngIntElt, J :: RngIntElt, s :: RngIntElt) -> BoolElt
  {True if there exists an extension of degree n of F whose ramification polygon has a point `(p^s, J)`.}
  require n ge 1: "n must be at least 1";
  require s ge 0: "s must be at least 0";
  p := Prime(F);
  ps := p^s;
  e := AbsoluteRamificationDegree(F);
  require s le Valuation(n,p): "p^s must divide n";
  return Min(n * e * BinomialValuation(J mod n, ps, p), n * e * BinomialValuation(n, ps, p)) le J
    and J le n * e * BinomialValuation(n, ps, p);
end intrinsic;

intrinsic OreConditions(F :: FldPadTmpl, n :: RngIntElt, J :: RngIntElt) -> BoolElt
  {True if there exists an extension of degree n and discriminant valuation `n+J-1` of F.}
  return OreConditions(F, n, J, 0);
end intrinsic;

intrinsic OrePossibilities(F :: FldPadTmpl, n :: RngIntElt, s :: RngIntElt) -> BoolElt
  {The possible J such that `(F,n,J,s)` satisfy Ore's conditions.}
  return [J : J in [0..n * AbsoluteRamificationDegree(F) * BinomialValuation(n, Prime(F)^s, Prime(F))]];
end intrinsic;

intrinsic OrePossibilities(F :: FldPadTmpl, n :: RngIntElt) -> []
  {The possible J such that `(F,n,J)` satisfy Ore's conditions.}
  return OrePossibilities(F, n, 0);
end intrinsic;

///## Elements
///
/// Elements of a template p-adic field are represented by their valuation and a finite sequence of p-adic coefficients, which are elements of the residue class field.
/// 
/// When the actual field is known, we provide maps between the template and actual field (accessible by the `Actual` intrinsic). For each element of the residue class field, we choose a representative in the actual field (specifically, we use the inverse of the map returned by `ResidueClassField` on the actual field). If `R` is the set of representatives, then the sequence of p-adic coefficients may be interpreted as a polynomial with coefficients in `R`. Evaluating this at the uniformizer of the actual field gives an integral element, which is then shifted by the valuation.

///hide
intrinsic Print(x :: FldPadTmplElt)
  {Print.}
  if IsZero(x) then
    printf "0";
  else
    printf "(%o; %o)", x`valuation, Join([Sprintf("%o", c) : c in x`coeffs], " ");
  end if;
end intrinsic;

/// Allows coercion into F any of the following:
/// - An element of F
/// - An element of the actual field of F (if defined)
/// - A sequence [c0,c1,...] of p-adic coefficients
/// - A tuple <v,[c0,c1,...]> of valuation and p-adic coefficients
/// - The integer 0
intrinsic IsCoercible(F :: FldPadTmpl, X) -> BoolElt, .
  {True if X is coercible into F.}
  return false, "wrong type";
end intrinsic;

///hide
intrinsic IsCoercible(F :: FldPadTmpl, X :: FldPadTmplElt) -> BoolElt, .
  {"}
  if Parent(X) eq F then
    return true, X;
  else
    return false, "wrong parent";
  end if;
end intrinsic;

///hide
intrinsic IsCoercible(F :: FldPadTmpl, X :: []) -> BoolElt, .
  {"}
  return IsCoercible(F, <0,X>);
end intrinsic;

///hide
intrinsic IsCoercible(F :: FldPadTmpl, X :: RngIntElt) -> BoolElt, .
  {"}
  if X eq 0 then
    x := New(FldPadTmplElt);
    x`parent := F;
    x`valuation := Infinity();
    x`coeffs := [];
    return true, x;
  else
    return false, "not zero";
  end if;
end intrinsic;

///hide
intrinsic IsCoercible(F :: FldPadTmpl, X :: FldPadElt) -> BoolElt, .
  {"}
  ok, A, m := HasActual(F);
  if ok then
    ok, x := IsCoercible(A, X);
    if ok then
      return true, x @@ m;
    else
      return false, x;
    end if;
  end if;
  return false, A;
end intrinsic;

///hide
intrinsic IsCoercible(F :: FldPadTmpl, X :: Tup) -> BoolElt, .
  {"}
  if #X ne 2 then
    return false, "wrong size";
  end if;
  if Type(X[1]) ne RngIntElt and Type(X[1]) ne Infty then
    return false, "First argument must be an integer or infinity";
  end if;
  v := X[1];
  ok, FF := HasResidueClassField(F);
  if not ok then
    return false, FF;
  end if;
  ok, coeffs := IsCoercible(PowerSequence(FF), X[2]);
  if not ok then
    return false, "Second argument must be a sequence of elements";
  end if;
  while #coeffs gt 0 and coeffs[1] eq 0 do
    v +:= 1;
    coeffs := coeffs[2..#coeffs];
  end while;
  while #coeffs gt 0 and coeffs[#coeffs] eq 0 do
    coeffs := coeffs[1..#coeffs-1];
  end while;
  if #coeffs eq 0 then
    v := Infinity();
  end if;
  if v eq Infinity() and #coeffs ne 0 then
    return false, "Second argument must be empty when first is infinite";
  end if;
  x := New(FldPadTmplElt);
  x`parent := F;
  x`valuation := v;
  x`coeffs := coeffs;
  return true, x;
end intrinsic;

intrinsic Parent(x :: FldPadTmplElt) -> FldPadTmpl
  {The field containing x.}
  return x`parent;
end intrinsic;

intrinsic IsZero(x :: FldPadTmplElt) -> BoolElt
  {True iff x is zero.}
  return #x`coeffs eq 0;
end intrinsic;

intrinsic Valuation(x :: FldPadTmplElt) -> BoolElt
  {The valuation of x.}
  return x`valuation;
end intrinsic;

intrinsic Actual(x :: FldPadTmplElt) -> FldPadElt
  {Coerces x into the actual field.}
  ok, A, m := HasActual(Parent(x));
  require ok: A;
  return x @ m;
end intrinsic;

///## Polynomial rings

intrinsic PolynomialRing(F :: FldPadTmpl) -> RngUPol_FldPadTmpl
  {The univariate polynomial ring over F.}
  if not assigned F`polynomial_ring then
    R := New(RngUPol_FldPadTmpl);
    R`base_ring := F;
    F`polynomial_ring := R;
  end if;
  return F`polynomial_ring;
end intrinsic;

intrinsic BaseRing(R :: RngUPol_FldPadTmpl) -> FldPadTmpl
  {The base ring.}
  return R`base_ring;
end intrinsic;

///hide
intrinsic Print(R :: RngUPol_FldPadTmpl)
  {Print.}
  printf "Univariate polynomial ring over %o", BaseRing(R);
end intrinsic;

///hide
intrinsic 'eq'(R :: RngUPol_FldPadTmpl, S :: RngUPol_FldPadTmpl) -> BoolElt
  {Equality.}
  return IsIdentical(R, S);
end intrinsic;

intrinsic HasActual(R :: RngUPol_FldPadTmpl) -> BoolElt, RngUPol, Map
  {True if R has an actual ring.}
  if not assigned R`actual then
    ok, A, m := HasActual(BaseRing(R));
    if not ok then
      return false, A, _;
    end if;
    R`actual := PolynomialRing(A);
    R`actual_map := Embedding(R, R`actual, m);
  end if;
  return true, R`actual, R`actual_map;
end intrinsic;

intrinsic Actual(R :: RngUPol_FldPadTmpl) -> RngUPol, Map
  {The actual ring of R.}
  ok, A, m := HasActual(R);
  require ok: A;
  return A, m;
end intrinsic;

intrinsic Embedding(R :: RngUPol_FldPadTmpl, A :: RngUPol[FldPad], m :: Map) -> Map
  {The embedding of R into A extending the embedding m of base rings.}
  require BaseRing(R) eq Domain(m) and BaseRing(A) eq Codomain(m): "m must map base rings";
  return map<R -> A | f :-> [c @ m : c in Coefficients(f)], g :-> [c @@ m : c in Coefficients(g)]>;
end intrinsic;

intrinsic Embedding(R :: RngUPol_FldPadTmpl, A :: RngUPol[FldPad]) -> Map
  {The embedding of R into A.}
  return Embedding(R, A, Embedding(BaseRing(R), BaseRing(A)));
end intrinsic;

///## Polynomials

///hide
intrinsic Print(f :: RngUPolElt_FldPadTmpl)
  {Print.}
  if IsZero(f) then
    printf "0";
  else
    printf "%o", Join([i eq 1 select Sprintf("%o",c) else i eq 2 select Sprintf("%o*x",c) else Sprintf("%o*x^%o", c, i-1) : i in [#f`coeffs..1 by -1] | not IsZero(c) where c:=f`coeffs[i]], " + ");
  end if;
end intrinsic;

/// We can coerce the following into R:
/// - Elements of R
/// - Elements of the actual ring of R (if defined)
/// - Polynomials over anything coercible to the base ring of R
/// - Sequences of anything coercible to the base ring of R
intrinsic IsCoercible(R :: RngUPol_FldPadTmpl, X) -> BoolElt, .
  {True if X is coercible into R.}
  return false, "wrong type";
end intrinsic;

///hide
intrinsic IsCoercible(R :: RngUPol_FldPadTmpl, X :: RngUPolElt_FldPadTmpl) -> BoolElt, .
  {"}
  if Parent(X) eq R then
    return true, X;
  else
    return false, "wrong ring";
  end if;
end intrinsic;

///hide
intrinsic IsCoercible(R :: RngUPol_FldPadTmpl, X :: RngUPolElt) -> BoolElt, .
  {"}
  return IsCoercible(R, Coefficients(X));
end intrinsic;

///hide
intrinsic IsCoercible(R :: RngUPol_FldPadTmpl, X :: []) -> BoolElt, .
  {"}
  ok, cs := CanChangeUniverse(X, BaseRing(R));
  if ok then
    while #cs gt 0 and IsZero(cs[#cs]) do
      cs := cs[1..#cs-1];
    end while;
    f := New(RngUPolElt_FldPadTmpl);
    f`parent := R;
    f`coeffs := cs;
    return true, f;
  end if;
  return false, "not coercible to the base ring";
end intrinsic;

intrinsic Parent(f :: RngUPolElt_FldPadTmpl) -> RngUPol_FldPadTmpl
  {The ring containing f.}
  return f`parent;
end intrinsic;

intrinsic BaseRing(f :: RngUPolElt_FldPadTmpl) -> FldPadTmpl
  {The base ring of f.}
  return BaseRing(Parent(f));
end intrinsic;

intrinsic Coefficients(f :: RngUPolElt_FldPadTmpl) -> []
  {The coefficients of f.}
  return f`coeffs;
end intrinsic;

intrinsic Degree(f :: RngUPolElt_FldPadTmpl) -> RngIntElt
  {The degree.}
  return #f`coeffs - 1;
end intrinsic;

intrinsic IsZero(f :: RngUPolElt_FldPadTmpl) -> BoolElt
  {True iff f is zero.}
  return #f`coeffs eq 0;
end intrinsic;

intrinsic Actual(f :: RngUPolElt_FldPadTmpl) -> RngUPolElt
  {Coerces x into the actual ring.}
  ok, A, m := HasActual(Parent(f));
  require ok: A;
  return f @ m;
end intrinsic;

intrinsic Extension(K :: FldPad, f :: RngUPolElt_FldPadTmpl, m :: Map) -> FldPad
  {The extension of K defined by f, with the polynomial embedding m.}
  require Domain(m) eq Parent(f) and Type(Codomain(m)) eq RngUPol and BaseRing(Codomain(m)) eq K: "m must map polynomials over the base ring of f to polynomials over K";
  if Precision(K) eq Infinity() then
    function mf(k)
      K2 := K;
      K2`DefaultPrecision := k;
      return m(f);
    end function;
    return ext<K | map<Z -> Codomain(m) | k :-> mf(k)>>;
  else
    return ext<K | m(f)>;
  end if;
end intrinsic;

intrinsic Extension(K :: FldPad, f :: RngUPolElt_FldPadTmpl) -> FldPad
  {The extension of K defined by f.}
  return Extension(K, f, Embedding(Parent(f), PolynomialRing(K)));
end intrinsic;

intrinsic ActualExtension(f :: RngUPolElt_FldPadTmpl) -> FldPad
  {The extension of the actual field defined by f.}
  A, m := Actual(Parent(f));
  return Extension(BaseRing(A), f, m);
end intrinsic;

///# Ramification polygons
///
/// A `PadRamifPgon` represents a set of points defining a ramification polygon, which is the Newton polygon of the *ramification polygon* `r(x) = f(pi x + pi) / pi^n` of the Eisenstein polynomial `f(x)` of degree `n`. Some of the points need not be vertices, but can lie on the interior of faces, and therefore this is a more refined invariant than just the polygon itself. The points must be of the form `[<1, J_0>, <p^s_1, J_1>, ..., <p^s_u, 0>, ..., <n, 0>]` where `s_u = v_p(n)`.
/// 
/// To each point, we can also assign a non-zero element of the residue class field, which is the leading p-adic coefficients of the corresponding ramification polygon. These are collectively called the *residues* of the ramification polygon. If we multiply the uniformizer of the corresponding extension by the residue `u`, then the residues are all multplied by `u^n`. This defines an equivalence relation between different sets of residues.
/// 
/// Additionally, we can assign a single non-zero element of the residue class field, which we call the *constant coefficient residue*, abbreviated to *CC-residue*, which is the leading p-adic coefficient of the constant coefficient of the corresponding Eisenstein polynomial `f`.
/// 
///toc

///hide
intrinsic Print(P :: PadRamifPgon)
  {Print.}
  vertices := SequenceToSet(ChangeUniverse(Vertices(P`pgon), car<Z,Z>));
  printf "Ramification Points [%o; %o]", Join([(j eq s(P,i)) select Sprintf("%o", J(P,i)) cat (i eq 0 or i eq u(P) or not P`vs[i+1] in vertices select "" else ",") else "." : j in (i eq u(P)) select [s(P,i)] else [s(P,i)..s(P,i+1)-1], i in [0..u(P)]], " "), Join([Sprintf("%o", v[1]) : v in P`tvs], " ");
  if assigned P`residues then
    printf " with residues %o", P`residues;
  end if;
  if assigned P`ccres then
    printf " with cc-residue %o", P`ccres;
  end if;
end intrinsic;

///## Creation

intrinsic IsCoercible_RamificationPolygon(F :: FldPadTmpl, vs :: []) -> BoolElt, PadRamifPgon
  {True if vs can be made into a ramification polygon over F. vs must be a list of `<x,y>` pairs of integers defining the points.}
  p := Prime(F);
  ok, vs := CanChangeUniverse(vs, car<Z,Z>);
  if not ok then
    return false, "vs not a sequence of pairs of integers";
  elif #vs lt 1 then
    return false, "no points";
  elif vs[1][1] ne 1 then
    return false, "should start at 1";
  elif vs[#vs][2] ne 0 then
    return false, "should end on 0";
  elif exists{i : i in [2..#vs] | vs[i][1] le vs[i-1][1]} then
    return false, "not sorted";
  elif exists{i : i in [2..#vs] | vs[i][2] gt vs[i-1][2]} then
    return false, "should be decreasing";
  end if;
  pgon := NewtonPolygon(vs : Faces:="Lower");
  if exists{v : v in vs | Evaluate(pgon, v[1]) ne v[2]} then
    return false, "not a convex polygon";
  end if;
  widx := Min([i : i in [1..#vs] | vs[i][2] eq 0]);
  wvs := vs[1..widx];
  if exists{v : v in wvs | not IsPowerOf(v[1], p)} then
    return false, "not powers of p";
  end if;
  ss := [s where ok,s:=IsPowerOf(v[1], p) : v in wvs];
  assert ss[1] eq 0;
  n := vs[#vs][1];
  u := #ss-1;
  assert u ge 0;
  ok, m := IsDivisibleBy(n, vs[widx][1]);
  if not ok then
    return false, "final vertex not multiple of last power of p";
  elif IsDivisibleBy(m, p) then
    return false, "p-powers in horizontal part";
  end if;
  tvs := vs[widx..#vs];
  assert forall{v : v in tvs | v[2] eq 0};
  Js := [v[2] : v in wvs];
  bs := [J mod n : J in Js];
  as := [J div n : J in Js];
  P := New(PadRamifPgon);
  P`F := F;
  P`vs := vs;
  P`tvs := tvs;
  P`wvs := wvs;
  P`n := n;
  P`u := u;
  P`Js := Js;
  P`bs := bs;
  P`as := as;
  P`ss := ss;
  P`pgon := pgon;
  return true, P;
end intrinsic;

intrinsic RamificationPolygon(F :: FldPadTmpl, vs :: []) -> PadRamifPgon
  {A ramification polygon over F.}
  ok, P := IsCoercible_RamificationPolygon(F, vs);
  require ok: P;
  return P;
end intrinsic;

intrinsic Copy(P :: PadRamifPgon) -> PadRamifPgon
  {Makes a copy of P.}
  P2 := New(PadRamifPgon);
  P2`F := P`F;
  P2`vs := P`vs;
  P2`tvs := P`tvs;
  P2`wvs := P`wvs;
  P2`n := P`n;
  P2`u := P`u;
  P2`Js := P`Js;
  P2`bs := P`bs;
  P2`as := P`as;
  P2`ss := P`ss;
  P2`pgon := P`pgon;
  if assigned P`residues then
    P2`residues := P`residues;
  end if;
  if assigned P`ccrespol then
    P2`ccrespol := P`ccrespol;
  end if;
  if assigned P`ccres then
    P2`ccres := P`ccres;
  end if;
  return P2;
end intrinsic;

///## Invariants

/// n (degree), p (prime), e (absolute ramification degree), u (number of wild faces), x_u=p^s_u (wild degree)
intrinsic n(P :: PadRamifPgon) -> RngIntElt
  {n}
  return P`n;
end intrinsic;

///ditto
intrinsic p(P :: PadRamifPgon) -> RngIntElt
  {p}
  return Prime(P`F);
end intrinsic;

///ditto
intrinsic e(P :: PadRamifPgon) -> RngIntElt
  {e}
  return AbsoluteRamificationDegree(P`F);
end intrinsic;

///ditto
intrinsic u(P :: PadRamifPgon) -> RngIntElt
  {u}
  return P`u;
end intrinsic;

///ditto
intrinsic su(P :: PadRamifPgon) -> RngIntElt
  {s_u}
  return s(P,u(P));
end intrinsic;

///ditto
intrinsic xu(P :: PadRamifPgon) -> RngIntElt
  {x_u}
  return x(P, u(P));
end intrinsic;

/// J_i = n a_i + b_i (heights of vertices), x_i = p^s_i (abscissas)
intrinsic J(P :: PadRamifPgon, i :: RngIntElt) -> RngIntElt
  {J_i}
  return P`Js[i+1];
end intrinsic;

///ditto
intrinsic a(P :: PadRamifPgon, i :: RngIntElt) -> RngIntElt
  {a_i}
  return P`as[i+1];
end intrinsic;

///ditto
intrinsic b(P :: PadRamifPgon, i :: RngIntElt) -> RngIntElt
  {b_i}
  return P`bs[i+1];
end intrinsic;

///ditto
intrinsic s(P :: PadRamifPgon, i :: RngIntElt) -> RngIntElt
  {s_i}
  return P`ss[i+1];
end intrinsic;

///ditto
intrinsic x(P :: PadRamifPgon, i :: RngIntElt) -> RngIntElt
  {p^s_i}
  return P`vs[i+1][1];
end intrinsic;

///## Valuations of binomials

intrinsic vbin(P :: PadRamifPgon, n :: RngIntElt, k :: RngIntElt) -> RngIntElt
  {Valuation of n choose k.}
  return e(P) * BinomialValuation(n, k, p(P));
end intrinsic;

intrinsic vbinp(P :: PadRamifPgon, n :: RngIntElt, i :: RngIntElt) -> RngIntElt
  {Valuation of n choose `p^i`.}
  return vbin(P, n, p(P)^i);
end intrinsic;

intrinsic vbinbp(P :: PadRamifPgon, j :: RngIntElt, i :: RngIntElt) -> RngIntElt
  {Valuation of `b_j` choose `p^i`.}
  return vbin(P, b(P,j), p(P)^i);
end intrinsic;

intrinsic vbinps(P :: PadRamifPgon, n :: RngIntElt, i :: RngIntElt) -> RngIntElt
  {The valuation of n choose `p^s_i`.}
  return vbin(P, n, x(P,i));
end intrinsic;

intrinsic vbinnps(P :: PadRamifPgon, i :: RngIntElt) -> RngIntElt
  {The valuation of `n` choose p^s_i.}
  return vbinps(P, n(P), i);
end intrinsic;

intrinsic vbinbps(P :: PadRamifPgon, j :: RngIntElt, i :: RngIntElt) -> RngIntElt
  {The valuation of `b_j` choose `p^s_i`.}
  return vbinps(P, b(P,j), i);
end intrinsic;

intrinsic vbinbps(P :: PadRamifPgon, i :: RngIntElt) -> RngIntElt
  {The valuation of `b_i choose p^s_i`.}
  return vbinbps(P, i, i);
end intrinsic;

intrinsic sbinres(P :: PadRamifPgon, n :: RngIntElt, k :: RngIntElt) -> FldFinElt
  {The residue class of n choose k shifted down to a unit.}
  return ShiftedBinomial(ResidueClassField(P`F), n, k) / UniformizerResidue(P`F)^BinomialValuation(n, k, Prime(P`F));
end intrinsic;

///## Validity
///
/// Some polygons correspond to ramification polygons of actual extensions, and some do not. The ones which do we refer to as *valid*, and there are 5 conditions (which we call "Ore", "Tame", "Congruence", "Bounding" and "Missing") which together are necessary and sufficient for validity.
/// 
/// A polygon which satisfies the Ore, Congruence and Bounding conditions is called *semivalid*, and so semivalidity is necessary for validity. A polygon which is semivalid remains semivalid if we remove some of its points, and so this is useful when enumerating all possibilities by introducing one point at a time.
/// 
/// We provide intrinsics to check for validity, semivalidity, and the 5 individual conditions. Each intrinsic also has a version with a leading underscore; this version does not cache its answer, but does provide more information in the case of failure.

///param Residues:=true Only checks the residues (if they are assigned) when this is true
intrinsic IsValid(P :: PadRamifPgon : Residues:=true) -> BoolElt
  {True if P corresponds to an actual extension.}
  if Residues then
    if not assigned P`is_valid then
      ok := _IsValid(P : Residues:=false);
      if ok and assigned P`residues then
        ok, pol := IsValidResidues(P, P`residues);
        if ok then
          P`ccrespol := pol;
        end if;
      end if;
      P`is_valid := ok;
    end if;
    return P`is_valid;
  else
    return _IsValid(P : Residues:=false);
  end if;
end intrinsic;

///hide
intrinsic _IsValid(P :: PadRamifPgon : Residues:=true) -> BoolElt
  {"}
  return _SatisfiesOreCondition(P) and _SatisfiesCongruenceCondition(P) and _SatisfiesBoundingCondition(P) and _SatisfiesTameCondition(P) and _SatisfiesMissingCondition(P) and (not Residues or not assigned P`residues or IsValidResidues(P, P`residues));
end intrinsic;

intrinsic IsSemivalid(P :: PadRamifPgon) -> BoolElt
  {True if P satisfies the Ore, congruence and bounding conditions, which are necessary (but not sufficient) for being valid.}
  if not assigned P`is_semivalid then
    P`is_semivalid := _SatisfiesOreCondition(P) and _SatisfiesCongruenceCondition(P) and _SatisfiesBoundingCondition(P);
  end if;
  return P`is_semivalid;
end intrinsic;

///hide
intrinsic _IsSemivalid(P :: PadRamifPgon) -> BoolElt
  {"}
  return _SatisfiesOreCondition(P) and _SatisfiesCongruenceCondition(P) and _SatisfiesBoundingCondition(P);
end intrinsic;

intrinsic SatisfiesOreCondition(P :: PadRamifPgon) -> BoolElt
  {True iff P satisfies the Ore conditions: `b_t=0 => a_t eq vB(n,p^s_t)`, `b_t>0 => B(b_t,p^s_t) le a_t le B(n,p^s_t)-1`.}
  if not assigned P`valid_ore then
    P`valid_ore := _SatisfiesOreCondition(P);
  end if;
  return P`valid_ore;
end intrinsic;

///hide
intrinsic _SatisfiesOreCondition(P :: PadRamifPgon) -> BoolElt, .
  {"}
  for t in [0..u(P)] do
    if b(P,t) eq 0 then
      if a(P,t) ne vbinnps(P,t) then
        return false, t;
      end if;
    else
      if vbinbps(P,t,t) gt a(P,t) or a(P,t) gt vbinnps(P,t)-1 then
        return false, t;
      end if;
    end if;
  end for;
  return true, _;
end intrinsic;

intrinsic SatisfiesTameCondition(P :: PadRamifPgon) -> BoolElt
  {True iff P satisfies the tame conditions: `p^s_u le j le n => (j,0) in P iff B(n,j)=0`.}
  if not assigned P`valid_tame then
    P`valid_tame := _SatisfiesTameCondition(P);
  end if;
  return P`valid_tame;
end intrinsic;

///hide
intrinsic _SatisfiesTameCondition(P :: PadRamifPgon) -> BoolElt
  {"}
  return CorrectTamePoints(P) eq P`tvs;
end intrinsic;

intrinsic CorrectTamePoints(P :: PadRamifPgon) -> []
  {The correct tame points for a valid P of this degree.}
  return [<j,0> : j in [xu(P)..n(P)] | BinomialValuation(n(P),j,p(P)) eq 0];
end intrinsic;

intrinsic WithCorrectTamePoints(P :: PadRamifPgon) -> PadRamifPgon
  {A copy of P with the correct tame points.}
  return RamificationPolygon(P`F, P`vs[1..P`u] cat CorrectTamePoints(P));
end intrinsic;

intrinsic SatisfiesCongruenceCondition(P :: PadRamifPgon) -> BoolElt
  {True if P satisfies the congruence conditions: `b_t = b_r => a_t - B(b_t,p^s_t) = a_r - B(b_r,p^s_r)`.}
  if not assigned P`valid_cong then
    P`valid_cong := _SatisfiesCongruenceCondition(P);
  end if;
  return P`valid_cong;
end intrinsic;

///hide
intrinsic _SatisfiesCongruenceCondition(P :: PadRamifPgon) -> BoolElt, ., .
  {"}
  for t in [0..u(P)] do
    for r in [0..t-1] do
      if b(P,t) eq b(P,r) then
        if a(P,t) - vbinbps(P,t,t) ne a(P,r) - vbinbps(P,r,r) then
          return false, r, t;
        end if;
      end if;
    end for;
  end for;
  return true, _, _;
end intrinsic;

intrinsic SatisfiesBoundingCondition(P :: PadRamifPgon) -> BoolElt
  {True if P satisfies the bounding conditions: `b_r eq 0, p^s_r le b_t => a_t ge B(n,p^s_r) - B(b_t,p^s_r) + B(b_t,p^s_t)` and `b_r ne 0, p^s_r le b_t => a_t ge a_r - B(b_t,p^s_r) + B(b_t,p^s_t) + 1[b_t lt b_r]`.}
  if not assigned P`valid_bound then
    P`valid_bound := _SatisfiesBoundingCondition(P);
  end if;
  return P`valid_bound;
end intrinsic;

///hide
intrinsic _SatisfiesBoundingCondition(P :: PadRamifPgon) -> BoolElt, ., .
  {"}
  for t in [0..u(P)] do
    for r in [0..u(P)] do
      if x(P,r) le b(P,t) then
        if b(P,r) eq 0 then
          if a(P,t) lt vbinnps(P,r) - vbinbps(P,t,r) + vbinbps(P,t,t) then
            return false, t, r;
          end if;
        else
          if a(P,t) lt a(P,r) - vbinbps(P,t,r) + vbinbps(P,t,t) + (b(P,t) lt b(P,r) select 1 else 0) then
            return false, t, r;
          end if;
        end if;
      end if;
    end for;
  end for;
  return true, _, _;
end intrinsic;

intrinsic SatisfiesMissingCondition(P :: PadRamifPgon) -> BoolElt
  {True if P satisfies the "missing" conditions: `s_t lt s lt s_(t+1) => Floor(X/n) le B(n,p^s) - 1` and `s_t lt s_(t+1), p^s le b_r => a_r ge Floor((X-b_r)/n) + B(b_r,p^s_r) - B(b_r,p^s) + 1` where `X = J_t + (J_(t+1)-J_t)*(x_(t+1)-x_t)/(p^s-x_t)`.}
  if not assigned P`valid_missing then
    P`valid_missing := _SatisfiesMissingCondition(P);
  end if;
  return P`valid_missing;
end intrinsic;

///hide
intrinsic _SatisfiesMissingCondition(P :: PadRamifPgon) -> BoolElt, ., .
  {"}
  for t in [0..u(P)-1] do
    for s0 in [s(P,t)+1..s(P,t+1)-1] do
      ps := p(P)^s0;
      X := J(P,t) + (J(P,t+1) - J(P,t)) * (ps - x(P,t)) / (x(P,t+1) - x(P,t));
      if Floor(X/n(P)) gt vbin(P,n(P),ps) - 1 then
        return false, s0, -1;
      end if;
      for r in [0..u(P)] do
        if ps le b(P,r) then
          if a(P,r) lt Floor((X-b(P,r))/n(P)) + vbinbps(P,r,r) - vbin(P,b(P,r),ps) + 1 then
            return false, s0, r;
          end if;
        end if;
      end for;
    end for;
  end for;
  return true, _, _;
end intrinsic;

///## Residues

///param Partial:=false When true, rs may be a partial assignment (i.e. have some undefined entries) and the check becomes necessary but not sufficient for exisence.
intrinsic IsValidResidues(P :: PadRamifPgon, rs :: [FldFinElt] : Partial:=false) -> BoolElt
  {True if rs is a valid assignment of residues to P, i.e. if there exists an Eisenstein polynomial with these residues. When true, also returns a polynomial whose roots are the possible leading p-adic coefficients of the constant coefficient.}
  FF := ResidueClassField(P`F);
  require IsValid(P : Residues:=false): "P must be valid";
  require Universe(rs) eq FF: "rs must be elements of the residue class field";
  require #rs le #P`vs: "too long";
  require forall{r : r in rs | r ne 0}: "rs must be non-zero";
  require Partial or forall{i : i in [1..#P`vs] | IsDefined(rs, i)}: "not a complete assignment";
  // first check tame residues
  ts := CorrectTameResidues(P);
  for i in [1..#ts] do
    if IsDefined(ts,i) and IsDefined(rs,i) then
      if ts[i] ne rs[i] then
        return false;
      end if;
    end if;
  end for;
  // now check if some equations have a solution in the residue class field
  // start with an equation for all units of FF
  R := PolynomialRing(FF);
  eqn := R.1^(#FF-1)-1;
  for t in [0..u(P)-1] do
    if IsDefined(rs, t+1) then
      if b(P,t) eq 0 then
        neweqn := R.1^a(P,t) - (rs[t+1])^-1 * sbinres(P, n(P), x(P,t));
        eqn := GCD(eqn, neweqn);
        if Degree(eqn) eq 0 then
          return false;
        end if;
      else
        for r in [0..t-1] do
          if IsDefined(rs, r+1) and b(P,r) eq b(P,t) then
            if a(P,t) ge a(P,r) then
              neweqn := R.1^(a(P,t)-a(P,r)) - rs[r+1] * sbinres(P, b(P,r), x(P,r)) / (rs[t+1] * sbinres(P, b(P,t), x(P,t)));
            else
              neweqn := R.1^(a(P,r)-a(P,t)) - rs[t+1] * sbinres(P, b(P,t), x(P,t)) / (rs[r+1] * sbinres(P, b(P,r), x(P,r)));
            end if;
            eqn := GCD(eqn, neweqn);
            if Degree(eqn) eq 0 then
              return false;
            end if;
          end if;
        end for;
      end if;
    end if;
  end for;
  return true, eqn;
end intrinsic;

intrinsic CorrectTameResidues(P :: PadRamifPgon) -> []
  {The correct tame residues of P, between `x_u` and `n`.}
  rs := [ResidueClassField(P`F)|];
  for i in [1..#P`tvs] do
    i2 := i + #P`wvs - 1;
    rs[i2] := Binomial(n(P), P`tvs[i][1]);
  end for;
  return rs;
end intrinsic;

///## Enumeration

/// All possible ramification polygons of extensions of F of degree n.
///param J0:=false When given, just produce the polygons with discriminant valuation `J0+n-1`.
///param WithResidues:=false When true, also enumerates over all possible residues (equivalent to calling `WithAllResidues` on each output).
///param WithCCResidues:=false When true, also enumerates over all possible CC-residues (implies `WithResidues`; equivalent to calling `WithCCResidues` on each output).
///param Classes:=false When true, limits the residues and CC-residues to representatives of equivalence classes (so that they still generate all extensions among them).
intrinsic AllRamificationPolygons(F :: FldPadTmpl, n :: RngIntElt : J0:=false, WithResidues:=false, WithCCResidues:=false, Classes:=false) -> []
  {All possible ramification polygons of extensions of F of degree n.}
  if WithCCResidues then
    return [P2 : P2 in WithAllCCResidues(P : Classes:=Classes), P in AllRamificationPolygons(F, n : J0:=J0, WithResidues, Classes:=Classes)];
  elif WithResidues then
    return [P2 : P2 in WithAllResidues(P : Classes:=Classes), P in AllRamificationPolygons(F,n : J0:=J0)];
  end if;
  require n ge 1: "n must be at least 1";
  p := Prime(F);
  ret := [];
  vn := Valuation(n, p);
  tail := [<p^vn, 0>] cat (n gt p^vn select [<n, 0>] else []);
  J0s := OrePossibilities(F, n);
  Jis := [OrePossibilities(F, n, i) : i in [1..vn-1]];
  if J0 cmpne false then
    if J0 in J0s then
      J0s := [J0];
    else
      return [];
    end if;
  end if;
  // deal with the tame case first
  if vn eq 0 then
    ok, P := IsCoercible_RamificationPolygon(F, tail);
    assert ok;
    P2 := WithCorrectTamePoints(P);
    assert IsValid(P2);
    return [P2];
  end if;
  // make an initial todo list
  todo := [];
  for J0 in J0s do
    if J0 gt 0 then
      vs := [<1,J0>];
      ok, P := IsCoercible_RamificationPolygon(F, vs cat tail);
      assert ok;
      if IsSemivalid(P) then
        Append(~todo, <1, vs>);
        P2 := WithCorrectTamePoints(P);
        if IsValid(P2) then
          Append(~ret, P2);
        end if;
      end if;
    end if;
  end for;
  // expand the list
  while #todo gt 0 do
    i, vs := Explode(todo[1]);
    todo := todo[2..#todo];
    if i lt vn then
      Append(~todo, <i+1, vs>);
      for J in Jis[i] do
        ok, P := IsCoercible_RamificationPolygon(F, vs cat [<p^i, J>] cat tail);
        if ok then
          assert J ne 0;
          if IsSemivalid(P) then
            Append(~todo, <i+1, vs cat [<p^i, J>]>);
            P2 := WithCorrectTamePoints(P);
            if IsValid(P2) then
              Append(~ret, P2);
            end if;
          end if;
        end if;
      end for;
    end if;
  end while;
  return ret;
end intrinsic;

///param Classes:=false When true, only return one per equivalence class.
intrinsic AllValidResidues(P :: PadRamifPgon : Classes:=false) -> []
  {All the residues which are valid for P, paired with the leading coefficient polynomial.}
  rs0 := CorrectTameResidues(P);
  todo := [rs0];
  ret := [];
  FF := ResidueClassField(P`F);
  for i in [i : i in [1..#P`wvs] | not IsDefined(rs0, i)] do
    new_todo := [];
    if Classes and i eq 1 then
      xs := [FF|];
      for x in FF do
        if x ne 0 then
          for y in xs do
            if IsPower(x/y, n(P)) then
              continue x;
            end if;
          end for;
          Append(~xs, x);
        end if;
      end for;
    else
      xs := FF;
    end if;
    for rs in todo do
      new_rs := rs;
      for x in xs do
        if x ne 0 then
          new_rs[i] := x;
          if IsValidResidues(P, rs : Partial) then
            Append(~new_todo, new_rs);
          end if;
        end if;
      end for;
    end for;
    todo := new_todo;
  end for;
  return [<rs,pol> where ok,pol:=IsValidResidues(P,rs) : rs in todo];
end intrinsic;

///param Classes:=false When true, only return one per equivalence class.
intrinsic WithAllResidues(P :: PadRamifPgon : Classes:=false) -> []
  {Copies of P with valid residues attached.}
  require IsValid(P): "P must be valid";
  ret := [];
  for x in AllValidResidues(P : Classes:=Classes) do
    P2 := Copy(P);
    P2`residues := x[1];
    P2`ccrespol := x[2];
    P2`is_valid := true;
    Append(~ret, P2);
  end for;
  return ret;
end intrinsic;

///param Classes:=false When true, only return one per equivalence class.
///param Residues When given, use these residues instead of the ones attached to P.
intrinsic AllCCResidues(P :: PadRamifPgon : Residues:=false, Classes:=false) -> []
  {All valid CC-residues for P.}
  require IsValid(P): "P must be valid";
  if Residues cmpeq false then
    require assigned P`residues: "residues must be assigned";
    pol := P`ccrespol;
  else
    ok, pol := IsValidResidues(P, Residues);
    require ok: "Residues must be valid";
  end if;
  rs := [x[1] : x in Roots(pol)];
  if Classes then
    cs := [];
    for r in rs do
      if not exists{c : c in cs | IsPower(c/r, n(P))} then
        Append(~cs, r);
      end if;
    end for;
    return cs;
  else
    return rs;
  end if;
end intrinsic;

///param Classes:=false When true, only return one per equivalence class.
intrinsic WithAllCCResidues(P :: PadRamifPgon : Classes:=false) -> []
  {Copies of P with valid CC-residues attached.}
  ret := [];
  for res in AllCCResidues(P : Classes:=Classes) do
    P2 := Copy(P);
    P2`ccres := res;
    Append(~ret, P2);
  end for;
  return ret;
end intrinsic;

///# Generating Eisenstein polynomials
///
///toc

///## Creation of templates

intrinsic TemplateForEisensteinPolynomialsByDegreeAndDisciminant(F :: FldPadTmpl, n :: RngIntElt, J :: RngIntElt) -> Tmpl_RngUPolElt_FldPadTmpl
  {Template for Eisenstein polynomials of degree n, discriminant valuation `n+J-1` over F.}
  require OreConditions(F, n, J): "parameters must satisfy Ore conditions";
  T := New(Tmpl_RngUPolElt_FldPadTmpl);
  T`R := PolynomialRing(F);
  b := J mod n;
  a := J div n;
  T`coeffs := [];
  p := Prime(F);
  e := AbsoluteRamificationDegree(F);
  for i in [0..n] do
    C := New(Tmpl_FldPadTmplElt);
    C`F := F;
    C`min_val := i eq n select 0 else i eq 0 select 1 else i ge b select Max(1+a-e*Valuation(i,p),1) else Max(2+a-e*Valuation(i,p),1);
    C`min_val_sharp := i in {0,n,b};
    C`max_val := i eq n select 0 else Floor(1 + 2*a + 2*b/n);
    if i eq n then
      C`residues := [{ResidueClassField(F)!1}];
    end if;
    Append(~T`coeffs, C);
  end for;
  return T;
end intrinsic;

///hide
intrinsic Print(T :: Tmpl_RngUPolElt_FldPadTmpl)
  {Print.}
  print "Template for an element of";
  IndentPush();
  print T`R;
  IndentPop();
  print "with coefficients";
  IndentPush();
  for i in [1..#T`coeffs] do
    printf "%2o ", i-1;
    Print(T`coeffs[i]);
    if i lt #T`coeffs then
      print "";
    end if;
  end for;
  IndentPop();
end intrinsic;

///param Residues When given, use these residues instead of the ones attached to P.
///param CCResidue When given, use this CC-residue instead of the one attached to P.
///param Shrink:=true When true, returns the smallest template possible; when false, just uses the discriminant to bound the template.
intrinsic TemplateForEisensteinPolynomials(P :: PadRamifPgon : Residues:=true, CCResidue:=false, Shrink:=true) -> Tmpl_RngUPolElt_FldPadTmpl
  {A template for Eisenstein polynomials with this ramification polygon.}
  require IsValid(P): "invalid";
  T := New(Tmpl_RngUPolElt_FldPadTmpl);
  T`R := PolynomialRing(P`F);
  C := [New(Tmpl_FldPadTmplElt) : i in [0..n(P)]];
  for i in [0..n(P)] do
    C[i+1]`F := P`F;
    C[i+1]`min_val := i eq n(P) select 0 else 1;
    C[i+1]`min_val_sharp := i eq 0;
    C[i+1]`max_val := i eq n(P) select 0 else Floor(1 + 2*a(P,0) + 2*b(P,0)/n(P));
    if i eq n(P) then
      C[i+1]`residues := [{ResidueClassField(P`F)!1}];
    end if;
  end for;
  // inequalities from the "bounding" condition
  for t in [0..u(P)] do
    if b(P,t) eq 0 then
      for i in [x(P,t)..n(P)-1] do
        C[i+1]`min_val := Max(C[i+1]`min_val, vbin(P,n(P),x(P,t)) - vbin(P,i,x(P,t)) + 1);
      end for;
    else
      for i in [x(P,t)..n(P)] do
        if i ne b(P,t) then
          C[i+1]`min_val := Max(C[i+1]`min_val, a(P,t) + 1 - vbin(P,i,x(P,t)) + (i lt b(P,t) select 1 else 0));
        end if;
      end for;
    end if;
  end for;
  // inequalities from the "missing" condition
  for t in [0..u(P)-1] do
    for s0 in [s(P,t)+1..s(P,t+1)-1] do
      ps := p(P)^s0;
      for i in [ps..n(P)] do
        C[i+1]`min_val := Max(C[i+1]`min_val, Floor((J(P,t) + (J(P,t+1)-J(P,t))*(ps-x(P,t))/(x(P,t+1)-x(P,t)) - i)/n(P)) + 2 - vbin(P,i,ps));
      end for;
    end for;
  end for;
  // sharp equalities from the "bounding" condition
  for t in [0..u(P)] do
    i := b(P,t);
    if i ne 0 then
      val := a(P,t) - vbin(P,i,x(P,t)) + 1;
      if C[i+1]`min_val_sharp then
        assert C[i+1]`min_val eq val;
      else
        assert C[i+1]`min_val le val;
        C[i+1]`min_val := val;
        C[i+1]`min_val_sharp := true;
      end if;
    end if;
  end for;
  // shrink
  if Shrink then
    M := Floor(Max([-s : s in Slopes(P`pgon)]));
    h, j := Quotrem(J(P,0) + M + 1, n(P));
    for i in [0..n(P)-1] do
      C[i+1]`max_val := Min(C[i+1]`max_val, h + (i lt j select 1 else 0));
    end for;
  end if;
  // residues
  if Residues cmpeq true select assigned P`residues else Residues cmpne false then
    FF := ResidueClassField(P`F);
    // get the set of residues
    if Residues cmpeq true then
      require assigned P`residues: "residues not assigned";
      rs := P`residues;
      ccrespol := P`ccrespol;
    else
      ok, rs := IsCoercible(PowerSequence(FF), Residues);
      require ok: "Residues must be a boolean or a sequence of elements of the residue class field";
      ok, ccrespol := IsValidResidues(P, rs);
      require ok: "Residues are not valid";
    end if;
    // get the residue of the leading coefficient
    if CCResidue cmpeq false then
      require assigned P`ccres: "constant coefficient residue not specified";
      ccres := P`ccres;
      assert Evaluate(ccrespol, ccres) eq 0;
    else
      ok, ccres := IsCoercible(FF, CCResidue);
      require ok: "CCResidue must be in the residue class field";
      require Evaluate(ccrespol, ccres) eq 0: "CCResidue not valid";
    end if;
    // assign residues
    for i in [1..#C] do
      if not assigned C[i]`residues then
        C[i]`residues := [PowerSet(FF)|];
      end if;
    end for;
    // set the residue of the leading coefficient
    C[1]`residues[1] := {-ccres};
    // set the other residues
    for t in [0..u(P)] do
      if b(P,t) ne 0 then
        C[b(P,t)+1]`residues[1] := {rs[t+1] * ccres^(1+a(P,t)) / sbinres(P,b(P,t),x(P,t))};
      end if;
    end for;
    // shrink
    if Shrink then
      RFF := PolynomialRing(FF);
      for m in [1..M] do
        vs1 := [<v[1], v[2]+v[1]*m> : v in P`vs];
        Cm := Min([v[2] : v in vs1]);
        h, j := Quotrem(Cm, n(P));
        vs2 := [<v[1], v[2] - Cm> : v in vs1];
        Sm := &+[RFF.1^vs2[i][1] * P`residues[i] : i in [1..#vs2] | vs2[i][2] eq 0];
        U := { ccres^(1 + h) * Evaluate(Sm, x) : x in FF };
        cosets := [];
        for x in FF do
          if not exists{c : c in cosets | c-x in U} then
            Append(~cosets, x);
          end if;
        end for;
        C[j+1]`residues[h+2-C[j+1]`min_val] := SequenceToSet(cosets);
      end for;
    end if;
  end if;
  T`coeffs := C;
  return T;
end intrinsic;

///hide
intrinsic Print(C :: Tmpl_FldPadTmplElt)
  {Print.}
  printf "%o", Join([Sprintf("min_val=%o", C`min_val)] cat (C`min_val_sharp select ["(sharp)"] else []) cat [Sprintf("max_val=%o", C`max_val)] cat (assigned C`residues and #C`residues gt 0 select [Sprintf("residues=%o",C`residues)] else []), " ");
end intrinsic;

///## Creation of polynomials

intrinsic '#'(T :: Tmpl_FldPadTmplElt) -> RngIntElt
  {The number of elements in the template.}
  return #IndexSet(T);
end intrinsic;

intrinsic '#'(T :: Tmpl_RngUPolElt_FldPadTmpl) -> RngIntElt
  {"}
  return #IndexSet(T);
end intrinsic;

intrinsic ToSequence(T :: Tmpl_FldPadTmplElt) -> []
  {The elements of T as a sequence.}
  return [GetIndex(T,idx) : idx in IndexSet(T)];
end intrinsic;

intrinsic ToSequence(T :: Tmpl_RngUPolElt_FldPadTmpl) -> []
  {"}
  return [GetIndex(T,idx) : idx in IndexSet(T)];
end intrinsic;

intrinsic Random(T :: Tmpl_FldPadTmplElt) -> FldPadTmplElt
  {A random element of T.}
  return GetIndex(T,Random(IndexSet(T)));
end intrinsic;

intrinsic Random(T :: Tmpl_RngUPolElt_FldPadTmpl) -> RngUPolElt_FldPadTmpl
  {"}
  return GetIndex(T,Random(IndexSet(T)));
end intrinsic;

intrinsic IndexSet(T :: Tmpl_FldPadTmplElt) -> .
  {A set of indices for elements of T. This is quick to generate and can be iterated over.}
  if not assigned T`index_set then
    FF := ResidueClassField(T`F);
    T`index_set := CartesianProduct(<assigned T`residues and IsDefined(T`residues,i-T`min_val+1) select T`residues[i-T`min_val+1] else i eq T`min_val and T`min_val_sharp select {x: x in FF | x ne 0} else FF : i in [T`min_val..T`max_val]>);
  end if;
  return T`index_set;
end intrinsic;

intrinsic IndexSet(T :: Tmpl_RngUPolElt_FldPadTmpl) -> .
  {"}
  if not assigned T`index_set then
    T`index_set := CartesianProduct(<IndexSet(c) : c in T`coeffs>);
  end if;
  return T`index_set;
end intrinsic;

intrinsic GetIndex(T :: Tmpl_FldPadTmplElt, idx) -> FldPadTmplElt
  {Gets the element of T at index idx (which should be an element of the index set).}
  return T`F ! <T`min_val, [c : c in idx]>;
end intrinsic;

intrinsic GetIndex(T :: Tmpl_RngUPolElt_FldPadTmpl, idx) -> RngUPolElt_FldPadTmpl
  {"}
  return T`R ! [GetIndex(T`coeffs[i], idx[i]) : i in [1..#T`coeffs]];
end intrinsic;
