// Implements functionality from "Enumerating extensions of (pi)-adic fields with given invariants" by Pauli and Sinclair.
// 
// F := TemplatepAdicField(2);
// P := RamificationPoints(F, [<1,10>,<8,0>]);
// T := TemplateForEisensteinPolynomials(P);
// the assertion error implies an inconsistency between Lemma 3.5 and Prop 3.10!

declare type PadRamifPts;
declare attributes PadRamifPts: F, vs, tvs, wvs, n, u, Js, bs, as, ss, pgon, valid_ore, valid_tame, valid_cong, valid_bound, valid_missing, is_valid, is_semivalid, residues, ccrespol, ccres;

declare type Tmpl_RngUPolElt_FldPadTmpl;
declare attributes Tmpl_RngUPolElt_FldPadTmpl: R, coeffs, index_set;

declare type Tmpl_FldPadTmplElt;
declare attributes Tmpl_FldPadTmplElt: F, min_val, min_val_sharp, max_val, residues, index_set;

Z := Integers();
Q := Rationals();

///# Miscellaneous

intrinsic FloorLog(b :: RngIntElt, x :: RngIntElt) -> RngIntElt
  {Equivalent to `Floor(Log(b,x))` but avoids any floating point arithmetic.}
  require b gt 0: "b must be positive";
  require x gt 0: "x must be positive";
  n := 0;
  while x ge b do
    n +:= 1;
    x div:= b;
  end while;
  return n;
end intrinsic;

// evaluates a piecewise-linear function vs at x
// vs: the function as a sequence of <x,y> pairs sorted by x
function plf_evaluate(vs, x)
  error if x lt vs[1][1] or x gt vs[#vs][1], "out of bounds";
  if #vs eq 1 then
    assert x eq vs[1][1];
    return vs[1][2];
  end if;
  assert exists(i){i : i in [2..#vs] | vs[i-1][1] le x and x le vs[i][1]};
  x0, y0 := Explode(vs[i-1]);
  x1, y1 := Explode(vs[i]);
  return y0 + (y1-y0)*(x-x0)/(x1-x0);  
end function;

intrinsic Evaluate(P :: NwtnPgon, x :: FldRatElt) -> FldRatElt
  {Treating P as a piecewise-linear function, evaluates it at x.}
  return plf_evaluate(Vertices(P), x);
end intrinsic;

intrinsic Evaluate(P :: NwtnPgon, x :: RngIntElt) -> FldRatElt
  {"}
  return Evaluate(P, Q!x);
end intrinsic;

intrinsic FactorialValuation(n :: RngIntElt, p :: RngIntElt) -> RngIntElt
  {The p-adic valuation of `n!` (equivalent to `Valuation(Factorial(n),p)` but more efficient).}
  require n ge 0: "n must be positive";
  v := 0;
  m := n;
  while m gt 0 do
    m div:= p;
    v +:= m;
  end while;
  return v;
end intrinsic;

intrinsic BinomialValuation(n :: RngIntElt, k :: RngIntElt, p :: RngIntElt) -> RngIntElt
  {The p-adic valuation of n choose k.}
  if k gt n or k lt 0 then
    return Infinity();
  else
    return FactorialValuation(n, p) - FactorialValuation(k, p) - FactorialValuation(n-k, p);
  end if;
end intrinsic;

intrinsic UnitFactorial(F :: FldFin, n :: RngIntElt) -> FldFinElt
  {The product of the integers up to n which are units in F. By Wilson's formula, if `n=kn+r` this is `(-1)^k * r!`.}
  require n ge 0: "n must be at least 0";
  p := Characteristic(F);
  if p eq 2 then
    return F ! 1;
  end if;
  k := n div p;
  r := n mod p;
  return (F!-1)^k * &*[F| i : i in [1..r]];
end intrinsic;

intrinsic ShiftedFactorial(F :: FldFin, n :: RngIntElt) -> FldFinElt
  {The product of the integers up to n shifted down to be units of F. This is the product of `UnitFactorial(n div p^i)` for all `i`.}
  require n ge 0: "n must be at least 0";
  p := Characteristic(F);
  if p eq 2 then
    return F ! 1;
  end if;
  ans := F!1;
  m := n;
  while m ne 0 do
    ans *:= UnitFactorial(F, m);
    m div:= p;
  end while;
  return ans;
end intrinsic;

intrinsic ShiftedBinomial(F :: FldFin, n :: RngIntElt, k :: RngIntElt) -> FldFinElt
  {The binomial coefficient n choose k shifted down to be a unit of F.}
  require 0 le n: "n must be at least 0";
  require 0 le k and k le n: "k must be between 0 and n";
  return ShiftedFactorial(F, n) / (ShiftedFactorial(F, k) * ShiftedFactorial(F, n-k));
end intrinsic;

///# Template p-adic fields
///
///toc

declare type FldPadTmpl[FldPadTmplElt];
declare attributes FldPadTmpl: p, d, e, f, actual, resfld, resmap, polynomial_ring;
declare attributes FldPadTmplElt: parent, coeffs, valuation;

declare type RngUPol_FldPadTmpl[RngUPolElt_FldPadTmpl];
declare attributes RngUPol_FldPadTmpl: base_ring;
declare attributes RngUPolElt_FldPadTmpl: parent, coeffs;

///## Creation

intrinsic TemplatepAdicField(p :: RngIntElt, f :: RngIntElt, e :: RngIntElt) -> FldPadTmpl
  {A "template" p-adic field with residue degree f and ramification degree e.}
  require IsPrime(p) and p gt 0: "p must be a prime";
  require f ge 1: "f must be positive";
  require e ge 1: "e must be positive";
  F := New(FldPadTmpl);
  F`p := p;
  F`e := e;
  F`f := f;
  F`d := e*f;
  return F;
end intrinsic;

intrinsic TemplatepAdicField(p :: RngIntElt) -> FldPadTmpl
  {A "template" p-adic field.}
  return TemplatepAdicField(p, 1, 1);
end intrinsic;

intrinsic TemplatepAdicField(K :: FldPad) -> FldPadTmpl
  {A "template" version of K.}
  F := New(FldPadTmpl);
  F`p := Prime(K);
  F`f := AbsoluteInertiaDegree(K);
  F`e := AbsoluteRamificationDegree(K);
  F`d := F`f * F`e;
  F`actual := K;
  return F;
end intrinsic;

///## Extensions

intrinsic UnramifiedExtension(F :: FldPadTmpl, n :: RngIntElt) -> FldPadTmpl
  {An unramified extension of F of degree n.}
  require n ge 1: "n must be positive";
  return TemplatepAdicField(F`p, F`f * n, F`e);
end intrinsic;

intrinsic TotallyRamifiedExtension(F :: FldPadTmpl, n :: RngIntElt) -> FldPadTmpl
  {A totally ramified extension of F of degree n.}
  require n ge 1: "n must be positive";
  return TemplatepAdicField(F`p, F`f, F`e * n);
end intrinsic;

///hide
intrinsic Print(F :: FldPadTmpl)
  {Print.}
  printf "Template %o-adic field (f=%o, e=%o)", F`p, F`f, F`e;
end intrinsic;

///hide
intrinsic 'eq'(F :: FldPadTmpl, E :: FldPadTmpl) -> BoolElt
  {Equality.}
  return IsIdentical(F, E);
end intrinsic;

///## Invariants

intrinsic Prime(F :: FldPadTmpl) -> RngIntElt
  {The prime `p`.}
  return F`p;
end intrinsic;

/// Absolute degree, inertia degree and ramification degree
intrinsic AbsoluteDegree(F :: FldPadTmpl) -> RngIntElt
  {Absolute degree.}
  return F`d;
end intrinsic;

///ditto
intrinsic AbsoluteInertiaDegree(F :: FldPadTmpl) -> RngIntElt
  {Absolute inertia degree.}
  return F`f;
end intrinsic;

///ditto
intrinsic AbsoluteRamificationDegree(F :: FldPadTmpl) -> RngIntElt
  {Absolute ramification degree.}
  return F`e;
end intrinsic;

intrinsic ResidueClassField(F :: FldPadTmpl) -> FldFin, Map
  {Residue class field. If F was created from an actual field, also returns the residue map.}
  if assigned F`actual then
    if not assigned F`resfld then
      F`resfld, F`resmap := ResidueClassField(Integers(F`actual));
    end if;
    return F`resfld, F`resmap;
  else
    if not assigned F`resfld then
      F`resfld := FiniteField(F`p^F`f);
    end if;
    return F`resfld, _;
  end if;
end intrinsic;

///## Actual field
///
/// If a template field was created from an actual field ([such as this](#TemplatepAdicField--FldPad)) then that field is remembered.

intrinsic HasActualField(F :: FldPadTmpl) -> BoolElt, FldPad
  {True if F is associated to an actual field. If so, also returns the field.}
  if assigned F`actual then
    return true, F`actual;
  else
    return false, _;
  end if;
end intrinsic;

intrinsic ActualField(F :: FldPadTmpl) -> FldPad
  {The actual field associated to F, if there is one.}
  ok, K := HasActualField(F);
  require ok: "does not have an actual field";
  return K;
end intrinsic;

///## Ore's conditions

intrinsic OreConditions(F :: FldPadTmpl, n :: RngIntElt, J :: RngIntElt, s :: RngIntElt) -> BoolElt
  {True if there exists an extension of degree n of F whose ramification polygon has a point `(p^s, J)`.}
  require n ge 1: "n must be at least 1";
  require s ge 0: "s must be at least 0";
  p := F`p;
  ps := p^s;
  e := F`e;
  require s le Valuation(n,p): "p^s must divide n";
  return Min(n * e * BinomialValuation(J mod n, ps, p), n * e * BinomialValuation(n, ps, p)) le J
    and J le n * e * BinomialValuation(n, ps, p);
end intrinsic;

intrinsic OreConditions(F :: FldPadTmpl, n :: RngIntElt, J :: RngIntElt) -> BoolElt
  {True if there exists an extension of degree n and discriminant valuation `n+J-1` of F.}
  return OreConditions(F, n, J, 0);
end intrinsic;

intrinsic OrePossibilities(F :: FldPadTmpl, n :: RngIntElt, s :: RngIntElt) -> BoolElt
  {The possible J such that `(F,n,J,s)` satisfy Ore's conditions.}
  return [J : J in [0..n * F`e * BinomialValuation(n, F`p^s, F`p)]];
end intrinsic;

intrinsic OrePossibilities(F :: FldPadTmpl, n :: RngIntElt) -> []
  {The possible J such that `(F,n,J)` satisfy Ore's conditions.}
  return OrePossibilities(F, n, 0);
end intrinsic;

///## Elements

///hide
intrinsic Print(x :: FldPadTmplElt)
  {Print.}
  if IsZero(x) then
    printf "0";
  else
    printf "(%o; %o)", x`valuation, Join([Sprintf("%o", c) : c in x`coeffs], " ");
  end if;
end intrinsic;

intrinsic IsCoercible(F :: FldPadTmpl, X) -> BoolElt, .
  {True if X is coercible into F.}
  return false, "wrong type";
end intrinsic;

intrinsic IsCoercible(F :: FldPadTmpl, X :: Tup) -> BoolElt, .
  {"}
  if #X ne 2 then
    return false, "wrong size";
  end if;
  if Type(X[1]) ne RngIntElt and Type(X[1]) ne Infty then
    return false, "First argument must be an integer or infinity";
  end if;
  v := X[1];
  ok, coeffs := IsCoercible(PowerSequence(ResidueClassField(F)), X[2]);
  if not ok then
    return false, "Second argument must be a sequence of elements";
  end if;
  while #coeffs gt 0 and coeffs[1] eq 0 do
    v +:= 1;
    coeffs := coeffs[2..#coeffs];
  end while;
  while #coeffs gt 0 and coeffs[#coeffs] eq 0 do
    coeffs := coeffs[1..#coeffs-1];
  end while;
  if #coeffs eq 0 then
    v := Infinity();
  end if;
  if v eq Infinity() and #coeffs ne 0 then
    return false, "Second argument must be empty when first is infinite";
  end if;
  x := New(FldPadTmplElt);
  x`parent := F;
  x`valuation := v;
  x`coeffs := coeffs;
  return true, x;
end intrinsic;

intrinsic Parent(x :: FldPadTmplElt) -> FldPadTmpl
  {The field containing x.}
  return x`parent;
end intrinsic;

intrinsic IsZero(x :: FldPadTmplElt) -> BoolElt
  {True iff x is zero.}
  return #x`coeffs eq 0;
end intrinsic;

intrinsic Valuation(x :: FldPadTmplElt) -> BoolElt
  {The valuation of x.}
  return x`valuation;
end intrinsic;

///## Polynomial rings

intrinsic PolynomialRing(F :: FldPadTmpl) -> RngUPol_FldPadTmpl
  {The univariate polynomial ring over F.}
  if not assigned F`polynomial_ring then
    R := New(RngUPol_FldPadTmpl);
    R`base_ring := F;
    F`polynomial_ring := R;
  end if;
  return F`polynomial_ring;
end intrinsic;

intrinsic BaseRing(R :: RngUPol_FldPadTmpl) -> FldPadTmpl
  {The base ring.}
  return R`base_ring;
end intrinsic;

///hide
intrinsic Print(R :: RngUPol_FldPadTmpl)
  {Print.}
  printf "Univariate polynomial ring over %o", BaseRing(R);
end intrinsic;

///hide
intrinsic 'eq'(R :: RngUPol_FldPadTmpl, S :: RngUPol_FldPadTmpl) -> BoolElt
  {Equality.}
  return IsIdentical(R, S);
end intrinsic;

///## Polynomials

///hide
intrinsic Print(f :: RngUPolElt_FldPadTmpl)
  {Print.}
  if IsZero(f) then
    printf "0";
  else
    printf "%o", Join([i eq 1 select Sprintf("%o",c) else i eq 2 select Sprintf("%o*x",c) else Sprintf("%o*x^%o", c, i-1) : i in [#f`coeffs..1 by -1] | not IsZero(c) where c:=f`coeffs[i]], " + ");
  end if;
end intrinsic;

intrinsic IsCoercible(R :: RngUPol_FldPadTmpl, X) -> BoolElt, .
  {True if X is coercible into R.}
  return false, "wrong type";
end intrinsic;

intrinsic IsCoercible(R :: RngUPol_FldPadTmpl, X :: [FldPadTmplElt]) -> BoolElt, .
  {"}
  if Universe(X) eq BaseRing(R) then
    f := New(RngUPolElt_FldPadTmpl);
    f`parent := R;
    while #X gt 0 and IsZero(X[#X]) do
      X := X[1..#X-1];
    end while;
    f`coeffs := X;
    return true, f;
  end if;
  return false, "wrong base ring";
end intrinsic;

intrinsic Parent(f :: RngUPolElt_FldPadTmpl) -> RngUPol_FldPadTmpl
  {The ring containing f.}
  return f`parent;
end intrinsic;

intrinsic BaseRing(f :: RngUPolElt_FldPadTmpl) -> FldPadTmpl
  {The base ring of f.}
  return BaseRing(Parent(f));
end intrinsic;

intrinsic Coefficients(f :: RngUPolElt_FldPadTmpl) -> []
  {The coefficients of f.}
  return f`coeffs;
end intrinsic;

intrinsic Degree(f :: RngUPolElt_FldPadTmpl) -> RngIntElt
  {The degree.}
  return #f`coeffs - 1;
end intrinsic;

intrinsic IsZero(f :: RngUPolElt_FldPadTmpl) -> BoolElt
  {True iff f is zero.}
  return #f`coeffs eq 0;
end intrinsic;

///# Ramification polygons
///
/// A `PadRamifPts` represents a set of points defining a ramification polygon. Some of the points need not be vertices, but can line on the interior of faces, and therefore this is a more refined invariant than ramification polygon.
///
///toc

///hide
intrinsic Print(P :: PadRamifPts)
  {Print.}
  vertices := SequenceToSet(ChangeUniverse(Vertices(P`pgon), car<Z,Z>));
  printf "Ramification Points [%o; %o]", Join([(j eq s(P,i)) select Sprintf("%o", J(P,i)) cat (i eq 0 or i eq u(P) or not P`vs[i+1] in vertices select "" else ",") else "." : j in (i eq u(P)) select [s(P,i)] else [s(P,i)..s(P,i+1)-1], i in [0..u(P)]], " "), Join([Sprintf("%o", v[1]) : v in P`tvs], " ");
  if assigned P`residues then
    printf " with residues %o", P`residues;
  end if;
  if assigned P`ccres then
    printf " with cc-residue %o", P`ccres;
  end if;
end intrinsic;

///## Creation

intrinsic IsCoercible_RamificationPoints(F :: FldPadTmpl, vs :: []) -> BoolElt, PadRamifPts
  {True if vs can be made into a potential set of ramification points over F. vs must be a list of `<x,y>` pairs of integers defining the points.}
  ok, vs := CanChangeUniverse(vs, car<Z,Z>);
  if not ok then
    return false, "vs not a sequence of pairs of integers";
  elif #vs lt 1 then
    return false, "no points";
  elif vs[1][1] ne 1 then
    return false, "should start at 1";
  elif vs[#vs][2] ne 0 then
    return false, "should end on 0";
  elif exists{i : i in [2..#vs] | vs[i][1] le vs[i-1][1]} then
    return false, "not sorted";
  elif exists{i : i in [2..#vs] | vs[i][2] gt vs[i-1][2]} then
    return false, "should be decreasing";
  end if;
  pgon := NewtonPolygon(vs : Faces:="Lower");
  if exists{v : v in vs | Evaluate(pgon, v[1]) ne v[2]} then
    return false, "not a convex polygon";
  end if;
  widx := Min([i : i in [1..#vs] | vs[i][2] eq 0]);
  wvs := vs[1..widx];
  if exists{v : v in wvs | not IsPowerOf(v[1], F`p)} then
    return false, "not powers of p";
  end if;
  ss := [s where ok,s:=IsPowerOf(v[1], F`p) : v in wvs];
  assert ss[1] eq 0;
  n := vs[#vs][1];
  u := #ss-1;
  assert u ge 0;
  ok, m := IsDivisibleBy(n, vs[widx][1]);
  if not ok then
    return false, "final vertex not multiple of last power of p";
  elif IsDivisibleBy(m, F`p) then
    return false, "p-powers in horizontal part";
  end if;
  tvs := vs[widx..#vs];
  assert forall{v : v in tvs | v[2] eq 0};
  Js := [v[2] : v in wvs];
  bs := [J mod n : J in Js];
  as := [J div n : J in Js];
  P := New(PadRamifPts);
  P`F := F;
  P`vs := vs;
  P`tvs := tvs;
  P`wvs := wvs;
  P`n := n;
  P`u := u;
  P`Js := Js;
  P`bs := bs;
  P`as := as;
  P`ss := ss;
  P`pgon := pgon;
  return true, P;
end intrinsic;

intrinsic RamificationPoints(F :: FldPadTmpl, vs :: []) -> PadRamifPts
  {A potential set of ramification points over F.}
  ok, P := IsCoercible_RamificationPoints(F, vs);
  require ok: P;
  return P;
end intrinsic;

intrinsic Copy(P :: PadRamifPts) -> PadRamifPts
  {Makes a copy of P.}
  P2 := New(PadRamifPts);
  P2`F := P`F;
  P2`vs := P`vs;
  P2`tvs := P`tvs;
  P2`wvs := P`wvs;
  P2`n := P`n;
  P2`u := P`u;
  P2`Js := P`Js;
  P2`bs := P`bs;
  P2`as := P`as;
  P2`ss := P`ss;
  P2`pgon := P`pgon;
  if assigned P`residues then
    P2`residues := P`residues;
  end if;
  if assigned P`ccrespol then
    P2`ccrespol := P`ccrespol;
  end if;
  if assigned P`ccres then
    P2`ccres := P`ccres;
  end if;
  return P2;
end intrinsic;

///## Invariants

/// n (degree), p (prime), e (absolute ramification degree), u (number of wild faces), x_u=p^s_u (wild degree)
intrinsic n(P :: PadRamifPts) -> RngIntElt
  {n}
  return P`n;
end intrinsic;

///ditto
intrinsic p(P :: PadRamifPts) -> RngIntElt
  {p}
  return P`F`p;
end intrinsic;

///ditto
intrinsic e(P :: PadRamifPts) -> RngIntElt
  {e}
  return P`F`e;
end intrinsic;

///ditto
intrinsic u(P :: PadRamifPts) -> RngIntElt
  {u}
  return P`u;
end intrinsic;

///ditto
intrinsic su(P :: PadRamifPts) -> RngIntElt
  {s_u}
  return s(P,u(P));
end intrinsic;

///ditto
intrinsic xu(P :: PadRamifPts) -> RngIntElt
  {x_u}
  return x(P, u(P));
end intrinsic;

/// J_i = n a_i + b_i (heights of vertices), x_i = p^s_i (abscissas)
intrinsic J(P :: PadRamifPts, i :: RngIntElt) -> RngIntElt
  {J_i}
  return P`Js[i+1];
end intrinsic;

///ditto
intrinsic a(P :: PadRamifPts, i :: RngIntElt) -> RngIntElt
  {a_i}
  return P`as[i+1];
end intrinsic;

///ditto
intrinsic b(P :: PadRamifPts, i :: RngIntElt) -> RngIntElt
  {b_i}
  return P`bs[i+1];
end intrinsic;

///ditto
intrinsic s(P :: PadRamifPts, i :: RngIntElt) -> RngIntElt
  {s_i}
  return P`ss[i+1];
end intrinsic;

///ditto
intrinsic x(P :: PadRamifPts, i :: RngIntElt) -> RngIntElt
  {p^s_i}
  return P`vs[i+1][1];
end intrinsic;

///## Valuations of binomials

intrinsic vbin(P :: PadRamifPts, n :: RngIntElt, k :: RngIntElt) -> RngIntElt
  {Valuation of n choose k.}
  return e(P) * BinomialValuation(n, k, p(P));
end intrinsic;

intrinsic vbinp(P :: PadRamifPts, n :: RngIntElt, i :: RngIntElt) -> RngIntElt
  {Valuation of n choose `p^i`.}
  return vbin(P, n, p(P)^i);
end intrinsic;

intrinsic vbinbp(P :: PadRamifPts, j :: RngIntElt, i :: RngIntElt) -> RngIntElt
  {Valuation of `b_j` choose `p^i`.}
  return vbin(P, b(P,j), p(P)^i);
end intrinsic;

intrinsic vbinps(P :: PadRamifPts, n :: RngIntElt, i :: RngIntElt) -> RngIntElt
  {The valuation of n choose `p^s_i`.}
  return vbin(P, n, x(P,i));
end intrinsic;

intrinsic vbinnps(P :: PadRamifPts, i :: RngIntElt) -> RngIntElt
  {The valuation of `n` choose p^s_i.}
  return vbinps(P, n(P), i);
end intrinsic;

intrinsic vbinbps(P :: PadRamifPts, j :: RngIntElt, i :: RngIntElt) -> RngIntElt
  {The valuation of `b_j` choose `p^s_i`.}
  return vbinps(P, b(P,j), i);
end intrinsic;

intrinsic vbinbps(P :: PadRamifPts, i :: RngIntElt) -> RngIntElt
  {The valuation of `b_i choose p^s_i`.}
  return vbinbps(P, i, i);
end intrinsic;

///## Validity

intrinsic _SatisfiesOreCondition(P :: PadRamifPts) -> BoolElt, .
  {True iff P satisfies the Ore conditions: `b_t=0 => a_t eq vB(n,p^s_t)`, `b_t>0 => B(b_t,p^s_t) le a_t le B(n,p^s_t)-1`.}
  for t in [0..u(P)] do
    if b(P,t) eq 0 then
      if a(P,t) ne vbinnps(P,t) then
        return false, t;
      end if;
    else
      if vbinbps(P,t,t) gt a(P,t) or a(P,t) gt vbinnps(P,t)-1 then
        return false, t;
      end if;
    end if;
  end for;
  return true, _;
end intrinsic;

intrinsic SatisfiesOreCondition(P :: PadRamifPts) -> BoolElt
  {"}
  if not assigned P`valid_ore then
    P`valid_ore := _SatisfiesOreCondition(P);
  end if;
  return P`valid_ore;
end intrinsic;

intrinsic _SatisfiesTameCondition(P :: PadRamifPts) -> BoolElt
  {True iff P satisfies the tame conditions: `p^s_u le j le n => (j,0) in P iff B(n,j)=0`.}
  return CorrectTamePoints(P) eq P`tvs;
end intrinsic;

intrinsic SatisfiesTameCondition(P :: PadRamifPts) -> BoolElt
  {"}
  if not assigned P`valid_tame then
    P`valid_tame := _SatisfiesTameCondition(P);
  end if;
  return P`valid_tame;
end intrinsic;

intrinsic CorrectTamePoints(P :: PadRamifPts) -> []
  {The correct tame points for a valid P of this degree.}
  return [<j,0> : j in [xu(P)..n(P)] | BinomialValuation(n(P),j,p(P)) eq 0];
end intrinsic;

intrinsic WithCorrectTamePoints(P :: PadRamifPts) -> PadRamifPts
  {A copy of P with the correct tame points.}
  return RamificationPoints(P`F, P`vs[1..P`u] cat CorrectTamePoints(P));
end intrinsic;

intrinsic _SatisfiesCongruenceCondition(P :: PadRamifPts) -> BoolElt, ., .
  {True if P satisfies the congruence conditions: `b_t = b_r => a_t - B(b_t,p^s_t) = a_r - B(b_r,p^s_r)`.}
  for t in [0..u(P)] do
    for r in [0..t-1] do
      if b(P,t) eq b(P,r) then
        if a(P,t) - vbinbps(P,t,t) ne a(P,r) - vbinbps(P,r,r) then
          return false, r, t;
        end if;
      end if;
    end for;
  end for;
  return true, _, _;
end intrinsic;

intrinsic SatisfiesCongruenceCondition(P :: PadRamifPts) -> BoolElt
  {"}
  if not assigned P`valid_cong then
    P`valid_cong := _SatisfiesCongruenceCondition(P);
  end if;
  return P`valid_cong;
end intrinsic;

intrinsic _SatisfiesBoundingCondition(P :: PadRamifPts) -> BoolElt, ., .
  {True if P satisfies the bounding conditions: `b_r eq 0, p^s_r le b_t => a_t ge B(n,p^s_r) - B(b_t,p^s_r) + B(b_t,p^s_t)` and `b_r ne 0, p^s_r le b_t => a_t ge a_r - B(b_t,p^s_r) + B(b_t,p^s_t) + 1[b_t lt b_r]`.}
  for t in [0..u(P)] do
    for r in [0..u(P)] do
      if x(P,r) le b(P,t) then
        if b(P,r) eq 0 then
          if a(P,t) lt vbinnps(P,r) - vbinbps(P,t,r) + vbinbps(P,t,t) then
            return false, t, r;
          end if;
        else
          if a(P,t) lt a(P,r) - vbinbps(P,t,r) + vbinbps(P,t,t) + (b(P,t) lt b(P,r) select 1 else 0) then
            return false, t, r;
          end if;
        end if;
      end if;
    end for;
  end for;
  return true, _, _;
end intrinsic;

intrinsic SatisfiesBoundingCondition(P :: PadRamifPts) -> BoolElt
  {"}
  if not assigned P`valid_bound then
    P`valid_bound := _SatisfiesBoundingCondition(P);
  end if;
  return P`valid_bound;
end intrinsic;

intrinsic _SatisfiesMissingCondition(P :: PadRamifPts) -> BoolElt, ., .
  {True if P satisfies the "missing" conditions: `s_t lt s lt s_(t+1) => Floor(X/n) le B(n,p^s) - 1` and `s_t lt s_(t+1), p^s le b_r => a_r ge Floor((X-b_r)/n) + B(b_r,p^s_r) - B(b_r,p^s) + 1` where `X = J_t + (J_(t+1)-J_t)*(x_(t+1)-x_t)/(p^s-x_t)`.}
  for t in [0..u(P)-1] do
    for s0 in [s(P,t)+1..s(P,t+1)-1] do
      ps := p(P)^s0;
      X := J(P,t) + (J(P,t+1) - J(P,t)) * (ps - x(P,t)) / (x(P,t+1) - x(P,t));
      if Floor(X/n(P)) gt vbin(P,n(P),ps) - 1 then
        return false, s0, -1;
      end if;
      for r in [0..u(P)] do
        if ps le b(P,r) then
          if a(P,r) lt Floor((X-b(P,r))/n(P)) + vbinbps(P,r,r) - vbin(P,b(P,r),ps) + 1 then
            return false, s0, r;
          end if;
        end if;
      end for;
    end for;
  end for;
  return true, _, _;
end intrinsic;

intrinsic SatisfiesMissingCondition(P :: PadRamifPts) -> BoolElt
  {"}
  if not assigned P`valid_missing then
    P`valid_missing := _SatisfiesMissingCondition(P);
  end if;
  return P`valid_missing;
end intrinsic;

intrinsic _IsSemivalid(P :: PadRamifPts) -> BoolElt
  {True if P satisfies the Ore, congruence and bounding conditions, which are necessary (but not sufficient) for being valid.}
  return _SatisfiesOreCondition(P) and _SatisfiesCongruenceCondition(P) and _SatisfiesBoundingCondition(P);
end intrinsic;

intrinsic IsSemivalid(P :: PadRamifPts) -> BoolElt
  {"}
  if not assigned P`is_semivalid then
    P`is_semivalid := _SatisfiesOreCondition(P) and _SatisfiesCongruenceCondition(P) and _SatisfiesBoundingCondition(P);
  end if;
  return P`is_semivalid;
end intrinsic;

/// True if P corresponds to an actual extension.
///param Residues:=true Only checks the residues (if they are assigned) when this is true
intrinsic _IsValid(P :: PadRamifPts : Residues:=true) -> BoolElt
  {True if P corresponds to an actual extension.}
  return _SatisfiesOreCondition(P) and _SatisfiesCongruenceCondition(P) and _SatisfiesBoundingCondition(P) and _SatisfiesTameCondition(P) and _SatisfiesMissingCondition(P) and (not Residues or not assigned P`residues or IsValidResidues(P, P`residues));
end intrinsic;

intrinsic IsValid(P :: PadRamifPts : Residues:=true) -> BoolElt
  {"}
  if Residues then
    if not assigned P`is_valid then
      ok := _IsValid(P : Residues:=false);
      if ok and assigned P`residues then
        ok, pol := IsValidResidues(P, P`residues);
        if ok then
          P`ccrespol := pol;
        end if;
      end if;
      P`is_valid := ok;
    end if;
    return P`is_valid;
  else
    return _IsValid(P : Residues:=false);
  end if;
end intrinsic;

///## Residues

/// True if rs is a valid assignment of residues to P, i.e. if there exists an Eisenstein polynomial with these residues. When true, also returns a polynomial whose roots are the possible leading p-adic coefficients of the constant coefficient.
/// 
///param Partial:=false When true, rs may be a partial assignment (i.e. have some undefined entries) and the check becomes necessary but not sufficient for exisence.
intrinsic IsValidResidues(P :: PadRamifPts, rs :: [FldFinElt] : Partial:=false) -> BoolElt
  {True if rs is a valid assignment of residues to P, i.e. if there exists an Eisenstein polynomial with these residues. When true, also returns a polynomial whose roots are the possible leading p-adic coefficients of the constant coefficient.}
  FF := ResidueClassField(P`F);
  require IsValid(P : Residues:=false): "P must be valid";
  require Universe(rs) eq FF: "rs must be elements of the residue class field";
  require #rs le #P`vs: "too long";
  require forall{r : r in rs | r ne 0}: "rs must be non-zero";
  require Partial or forall{i : i in [1..#P`vs] | IsDefined(rs, i)}: "not a complete assignment";
  // first check tame residues
  ts := CorrectTameResidues(P);
  for i in [1..#ts] do
    if IsDefined(ts,i) and IsDefined(rs,i) then
      if ts[i] ne rs[i] then
        return false;
      end if;
    end if;
  end for;
  // now check if some equations have a solution in the residue class field
  // start with an equation for all units of FF
  R := PolynomialRing(FF);
  eqn := R.1^(#FF-1)-1;
  for t in [0..u(P)-1] do
    if IsDefined(rs, t+1) then
      if b(P,t) eq 0 then
        neweqn := R.1^a(P,t) - (rs[t+1])^-1 * ShiftedBinomial(FF, n(P), x(P,t));
        eqn := GCD(eqn, neweqn);
        if Degree(eqn) eq 0 then
          return false;
        end if;
      else
        for r in [0..t-1] do
          if IsDefined(rs, r+1) and b(P,r) eq b(P,t) then
            if a(P,t) ge a(P,r) then
              neweqn := R.1^(a(P,t)-a(P,r)) - rs[r+1] * ShiftedBinomial(FF, b(P,r), x(P,r)) / (rs[t+1] * ShiftedBinomial(FF, b(P,t), x(P,t)));
            else
              neweqn := R.1^(a(P,r)-a(P,t)) - rs[t+1] * ShiftedBinomial(FF, b(P,t), x(P,t)) / (rs[r+1] * ShiftedBinomial(FF, b(P,r), x(P,r)));
            end if;
            eqn := GCD(eqn, neweqn);
            if Degree(eqn) eq 0 then
              return false;
            end if;
          end if;
        end for;
      end if;
    end if;
  end for;
  return true, eqn;
end intrinsic;

intrinsic CorrectTameResidues(P :: PadRamifPts) -> []
  {The correct tame residues of P, between `x_u` and `n`.}
  rs := [ResidueClassField(P`F)|];
  for i in [1..#P`tvs] do
    i2 := i + #P`wvs - 1;
    rs[i2] := Binomial(n(P), P`tvs[i][1]);
  end for;
  return rs;
end intrinsic;

///## Enumeration

/// All possible ramification points of extensions of F of degree n.
///param J0:=false When given, just produce the points with discriminant valuation `J0+n-1`
intrinsic AllRamificationPoints(F :: FldPadTmpl, n :: RngIntElt : J0:=false) -> []
  {All possible ramification points of extensions of F of degree n.}
  require n ge 1: "n must be at least 1";
  p := F`p;
  ret := [];
  vn := Valuation(n, p);
  tail := [<p^vn, 0>] cat (n gt p^vn select [<n, 0>] else []);
  J0s := OrePossibilities(F, n);
  Jis := [OrePossibilities(F, n, i) : i in [1..vn-1]];
  if J0 cmpne false then
    if J0 in J0s then
      J0s := [J0];
    else
      return [];
    end if;
  end if;
  // deal with the tame case first
  if vn eq 0 then
    ok, P := IsCoercible_RamificationPoints(F, tail);
    assert ok;
    P2 := WithCorrectTamePoints(P);
    assert IsValid(P2);
    return [P2];
  end if;
  // make an initial todo list
  todo := [];
  for J0 in J0s do
    if J0 gt 0 then
      vs := [<1,J0>];
      ok, P := IsCoercible_RamificationPoints(F, vs cat tail);
      assert ok;
      if IsSemivalid(P) then
        Append(~todo, <1, vs>);
        P2 := WithCorrectTamePoints(P);
        if IsValid(P2) then
          Append(~ret, P2);
        end if;
      end if;
    end if;
  end for;
  // expand the list
  while #todo gt 0 do
    i, vs := Explode(todo[1]);
    todo := todo[2..#todo];
    if i lt vn then
      Append(~todo, <i+1, vs>);
      for J in Jis[i] do
        ok, P := IsCoercible_RamificationPoints(F, vs cat [<p^i, J>] cat tail);
        if ok then
          assert J ne 0;
          if IsSemivalid(P) then
            Append(~todo, <i+1, vs cat [<p^i, J>]>);
            P2 := WithCorrectTamePoints(P);
            if IsValid(P2) then
              Append(~ret, P2);
            end if;
          end if;
        end if;
      end for;
    end if;
  end while;
  return ret;
end intrinsic;

intrinsic AllValidResidues(P :: PadRamifPts) -> []
  {All the residues which are valid for P, paired with the leading coefficient polynomial.}
  todo := [CorrectTameResidues(P)];
  ret := [];
  FF := ResidueClassField(P`F);
  while #todo gt 0 do
    rs := todo[1];
    todo := todo[2..#todo];
    if exists(i){i : i in [1..#P`wvs] | not IsDefined(rs, i)} then
      for x in FF do
        if x ne 0 then
          rs[i] := x;
          if IsValidResidues(P, rs : Partial) then
            Append(~todo, rs);
          end if;
        end if;
      end for;
    else
      Append(~ret, rs);
    end if;
  end while;
  return [<rs,pol> where ok,pol:=IsValidResidues(P,rs) : rs in ret];
end intrinsic;

intrinsic WithAllValidResidues(P :: PadRamifPts) -> []
  {Copies of P with valid residues attached.}
  require IsValid(P): "P must be valid";
  ret := [];
  for x in AllValidResidues(P) do
    P2 := Copy(P);
    P2`residues := x[1];
    P2`ccrespol := x[2];
    P2`is_valid := true;
    Append(~ret, P2);
  end for;
  return ret;
end intrinsic;

intrinsic AllCCResidues(P :: PadRamifPts : Residues:=false, Classes:=false) -> []
  {All valid CC-residues for P.}
  require IsValid(P): "P must be valid";
  if Residues cmpeq false then
    require assigned P`residues: "residues must be assigned";
    pol := P`ccrespol;
  else
    ok, pol := IsValidResidues(P, Residues);
    require ok: "Residues must be valid";
  end if;
  rs := [x[1] : x in Roots(pol)];
  if Classes then
    cs := [];
    for r in rs do
      if not exists{c : c in cs | IsPower(c/r, n(P))} then
        Append(~cs, r);
      end if;
    end for;
    return cs;
  else
    return rs;
  end if;
end intrinsic;

intrinsic WithAllCCResidues(P :: PadRamifPts : Classes:=false) -> []
  {Copies of P with valid CC-residues attached.}
  ret := [];
  for res in AllCCResidues(P : Classes:=Classes) do
    P2 := Copy(P);
    P2`ccres := res;
    Append(~ret, P2);
  end for;
  return ret;
end intrinsic;

///# Generating Eisenstein polynomials
///
///toc

///## Creation of templates

intrinsic TemplateForEisensteinPolynomialsByDegreeAndDisciminant(F :: FldPadTmpl, n :: RngIntElt, J :: RngIntElt) -> Tmpl_RngUPolElt_FldPadTmpl
  {Template for Eisenstein polynomials of degree n, discriminant valuation `n+J-1` over F.}
  require OreConditions(F, n, J): "parameters must satisfy Ore conditions";
  T := New(Tmpl_RngUPolElt_FldPadTmpl);
  T`R := PolynomialRing(F);
  b := J mod n;
  a := J div n;
  T`coeffs := [];
  for i in [0..n] do
    C := New(Tmpl_FldPadTmplElt);
    C`F := F;
    C`min_val := i eq n select 0 else i eq 0 select 1 else i ge b select Max(1+a-F`e*Valuation(i,F`p),1) else Max(2+a-F`e*Valuation(i,F`p),1);
    C`min_val_sharp := i in {0,n,b};
    C`max_val := i eq n select 0 else Floor(1 + 2*a + 2*b/n);
    if i eq n then
      C`residues := [{ResidueClassField(F)!1}];
    end if;
    Append(~T`coeffs, C);
  end for;
  return T;
end intrinsic;

///hide
intrinsic Print(T :: Tmpl_RngUPolElt_FldPadTmpl)
  {Print.}
  print "Template for an element of";
  IndentPush();
  print T`R;
  IndentPop();
  print "with coefficients";
  IndentPush();
  for i in [1..#T`coeffs] do
    printf "%2o ", i-1;
    Print(T`coeffs[i]);
    if i lt #T`coeffs then
      print "";
    end if;
  end for;
  IndentPop();
end intrinsic;

intrinsic TemplateForEisensteinPolynomials(P :: PadRamifPts : Residues:=true, CCResidue:=false, Shrink:=true) -> Tmpl_RngUPolElt_FldPadTmpl
  {A template for Eisenstein polynomials with this ramification polygon.}
  require IsValid(P): "invalid";
  T := New(Tmpl_RngUPolElt_FldPadTmpl);
  T`R := PolynomialRing(P`F);
  C := [New(Tmpl_FldPadTmplElt) : i in [0..n(P)]];
  for i in [0..n(P)] do
    C[i+1]`F := P`F;
    C[i+1]`min_val := i eq n(P) select 0 else 1;
    C[i+1]`min_val_sharp := i eq 0;
    C[i+1]`max_val := i eq n(P) select 0 else Floor(1 + 2*a(P,0) + 2*b(P,0)/n(P));
    if i eq n(P) then
      C[i+1]`residues := [{ResidueClassField(P`F)!1}];
    end if;
  end for;
  // inequalities from the "bounding" condition
  for t in [0..u(P)] do
    if b(P,t) eq 0 then
      for i in [x(P,t)..n(P)-1] do
        C[i+1]`min_val := Max(C[i+1]`min_val, vbin(P,n(P),x(P,t)) - vbin(P,i,x(P,t)) + 1);
      end for;
    else
      for i in [x(P,t)..n(P)] do
        if i ne b(P,t) then
          C[i+1]`min_val := Max(C[i+1]`min_val, a(P,t) + 1 - vbin(P,i,x(P,t)) + (i lt b(P,t) select 1 else 0));
        end if;
      end for;
    end if;
  end for;
  // inequalities from the "missing" condition
  for t in [0..u(P)-1] do
    for s0 in [s(P,t)+1..s(P,t+1)-1] do
      ps := p(P)^s0;
      for i in [ps..n(P)] do
        C[i+1]`min_val := Max(C[i+1]`min_val, Floor((J(P,t) + (J(P,t+1)-J(P,t))*(ps-x(P,t))/(x(P,t+1)-x(P,t)) - i)/n(P)) + 2 - vbin(P,i,ps));
      end for;
    end for;
  end for;
  // sharp equalities from the "bounding" condition
  for t in [0..u(P)] do
    i := b(P,t);
    if i ne 0 then
      val := a(P,t) - vbin(P,i,x(P,t)) + 1;
      if C[i+1]`min_val_sharp then
        assert C[i+1]`min_val eq val;
      else
        assert C[i+1]`min_val le val;
        C[i+1]`min_val := val;
        C[i+1]`min_val_sharp := true;
      end if;
    end if;
  end for;
  // shrink
  if Shrink then
    M := Floor(Max([-s : s in Slopes(P`pgon)]));
    h, j := Quotrem(J(P,0) + M + 1, n(P));
    for i in [0..n(P)-1] do
      C[i+1]`max_val := Min(C[i+1]`max_val, h + (i lt j select 1 else 0));
    end for;
  end if;
  // residues
  if Residues cmpeq true select assigned P`residues else Residues cmpne false then
    FF := ResidueClassField(P`F);
    // get the set of residues
    if Residues cmpeq true then
      require assigned P`residues: "residues not assigned";
      rs := P`residues;
      ccrespol := P`ccrespol;
    else
      ok, rs := IsCoercible(PowerSequence(FF), Residues);
      require ok: "Residues must be a boolean or a sequence of elements of the residue class field";
      ok, ccrespol := IsValidResidues(P, rs);
      require ok: "Residues are not valid";
    end if;
    // get the residue of the leading coefficient
    if CCResidue cmpeq false then
      require assigned P`ccres: "constant coefficient residue not specified";
      ccres := P`ccres;
      assert Evaluate(ccrespol, ccres) eq 0;
    else
      ok, ccres := IsCoercible(FF, CCResidue);
      require ok: "CCResidue must be in the residue class field";
      require Evaluate(ccrespol, ccres) eq 0: "CCResidue not valid";
    end if;
    // assign residues
    for i in [1..#C] do
      if not assigned C[i]`residues then
        C[i]`residues := [PowerSet(FF)|];
      end if;
    end for;
    // set the residue of the leading coefficient
    C[1]`residues[1] := {-ccres};
    // set the other residues
    for t in [0..u(P)] do
      if b(P,t) ne 0 then
        C[b(P,t)+1]`residues[1] := {rs[t+1] * ccres^(1+a(P,t)) / ShiftedBinomial(FF,b(P,t),x(P,t))};
      end if;
    end for;
    // shrink
    if Shrink then
      RFF := PolynomialRing(FF);
      for m in [1..M] do
        vs1 := [<v[1], v[2]+v[1]*m> : v in P`vs];
        Cm := Min([v[2] : v in vs1]);
        h, j := Quotrem(Cm, n(P));
        vs2 := [<v[1], v[2] - Cm> : v in vs1];
        Sm := &+[RFF.1^vs2[i][1] * P`residues[i] : i in [1..#vs2] | vs2[i][2] eq 0];
        U := { ccres^(1 + h) * Evaluate(Sm, x) : x in FF };
        cosets := [];
        for x in FF do
          if not exists{c : c in cosets | c-x in U} then
            Append(~cosets, x);
          end if;
        end for;
        C[j+1]`residues[h+1] := SequenceToSet(cosets);
      end for;
    end if;
  end if;
  T`coeffs := C;
  return T;
end intrinsic;

///hide
intrinsic Print(C :: Tmpl_FldPadTmplElt)
  {Print.}
  printf "%o", Join([Sprintf("min_val=%o", C`min_val)] cat (C`min_val_sharp select ["(sharp)"] else []) cat [Sprintf("max_val=%o", C`max_val)] cat (assigned C`residues and #C`residues gt 0 select [Sprintf("residues=%o",C`residues)] else []), " ");
end intrinsic;

///## Creation of polynomials

intrinsic '#'(T :: Tmpl_FldPadTmplElt) -> RngIntElt
  {The number of elements in the template.}
  return #IndexSet(T);
end intrinsic;

intrinsic '#'(T :: Tmpl_RngUPolElt_FldPadTmpl) -> RngIntElt
  {"}
  return #IndexSet(T);
end intrinsic;

intrinsic ToSequence(T :: Tmpl_FldPadTmplElt) -> []
  {The elements of T as a sequence.}
  return [GetIndex(T,idx) : idx in IndexSet(T)];
end intrinsic;

intrinsic ToSequence(T :: Tmpl_RngUPolElt_FldPadTmpl) -> []
  {"}
  return [GetIndex(T,idx) : idx in IndexSet(T)];
end intrinsic;

intrinsic Random(T :: Tmpl_FldPadTmplElt) -> FldPadTmplElt
  {A random element of T.}
  return GetIndex(T,Random(IndexSet(T)));
end intrinsic;

intrinsic Random(T :: Tmpl_RngUPolElt_FldPadTmpl) -> RngUPolElt_FldPadTmpl
  {"}
  return GetIndex(T,Random(IndexSet(T)));
end intrinsic;

intrinsic IndexSet(T :: Tmpl_FldPadTmplElt) -> .
  {A set of indices for elements of T. This is quick to generate and can be iterated over.}
  if not assigned T`index_set then
    FF := ResidueClassField(T`F);
    T`index_set := CartesianProduct(<assigned T`residues and IsDefined(T`residues,i-T`min_val+1) select T`residues[i-T`min_val+1] else i eq T`min_val and T`min_val_sharp select {x: x in FF | x ne 0} else FF : i in [T`min_val..T`max_val]>);
  end if;
  return T`index_set;
end intrinsic;

intrinsic IndexSet(T :: Tmpl_RngUPolElt_FldPadTmpl) -> .
  {"}
  if not assigned T`index_set then
    T`index_set := CartesianProduct(<IndexSet(c) : c in T`coeffs>);
  end if;
  return T`index_set;
end intrinsic;

intrinsic GetIndex(T :: Tmpl_FldPadTmplElt, idx) -> FldPadTmplElt
  {Gets the element of T at index idx (which should be an element of the index set).}
  return T`F ! <T`min_val, [c : c in idx]>;
end intrinsic;

intrinsic GetIndex(T :: Tmpl_RngUPolElt_FldPadTmpl, idx) -> RngUPolElt_FldPadTmpl
  {"}
  return T`R ! [GetIndex(T`coeffs[i], idx[i]) : i in [1..#T`coeffs]];
end intrinsic;
